diff --git a/src/builtins/accessors.cc b/src/builtins/accessors.cc
index 8d26259204..4a5ab16fe4 100644
--- a/src/builtins/accessors.cc
+++ b/src/builtins/accessors.cc
@@ -473,9 +473,16 @@ Handle<JSObject> GetFrameArguments(Isolate* isolate,
     return ArgumentsForInlinedFunction(frame, function_index);
   }
 
+  // Find the frame that holds the actual arguments passed to the function.
+  if (it->frame()->has_adapted_arguments()) {
+    it->AdvanceOneFrame();
+    DCHECK(it->frame()->is_arguments_adaptor());
+  }
+  frame = it->frame();
+  const int length = frame->ComputeParametersCount();
+
   // Construct an arguments object mirror for the right frame and the underlying
   // function.
-  const int length = frame->GetActualArgumentCount();
   Handle<JSFunction> function(frame->function(), isolate);
   Handle<JSObject> arguments =
       isolate->factory()->NewArgumentsObject(function, length);
diff --git a/src/builtins/arm/builtins-arm.cc b/src/builtins/arm/builtins-arm.cc
index 533475d96c..d02e35cd56 100644
--- a/src/builtins/arm/builtins-arm.cc
+++ b/src/builtins/arm/builtins-arm.cc
@@ -805,18 +805,6 @@ static void LeaveInterpreterFrame(MacroAssembler* masm, Register scratch1,
   __ ldr(params_size,
          FieldMemOperand(params_size, BytecodeArray::kParameterSizeOffset));
 
-  Register actual_params_size = scratch2;
-  // Compute the size of the actual parameters + receiver (in bytes).
-  __ ldr(actual_params_size,
-         MemOperand(fp, StandardFrameConstants::kArgCOffset));
-  __ lsl(actual_params_size, actual_params_size, Operand(kPointerSizeLog2));
-  __ add(actual_params_size, actual_params_size, Operand(kSystemPointerSize));
-
-  // If actual is bigger than formal, then we should use it to free up the stack
-  // arguments.
-  __ cmp(params_size, actual_params_size);
-  __ mov(params_size, actual_params_size, LeaveCC, lt);
-
   // Leave the frame (also dropping the register file).
   __ LeaveFrame(StackFrame::INTERPRETED);
 
@@ -1993,6 +1981,29 @@ void Builtins::Generate_ReflectConstruct(MacroAssembler* masm) {
           RelocInfo::CODE_TARGET);
 }
 
+static void EnterArgumentsAdaptorFrame(MacroAssembler* masm) {
+  __ SmiTag(r0);
+  __ mov(r4, Operand(StackFrame::TypeToMarker(StackFrame::ARGUMENTS_ADAPTOR)));
+  __ stm(db_w, sp, r0.bit() | r1.bit() | r4.bit() |
+                       fp.bit() | lr.bit());
+  __ Push(Smi::zero());  // Padding.
+  __ add(fp, sp,
+         Operand(ArgumentsAdaptorFrameConstants::kFixedFrameSizeFromFp));
+}
+
+static void LeaveArgumentsAdaptorFrame(MacroAssembler* masm) {
+  // ----------- S t a t e -------------
+  //  -- r0 : result being passed through
+  // -----------------------------------
+  // Get the number of arguments passed (as a smi), tear down the frame and
+  // then tear down the parameters.
+  __ ldr(r1, MemOperand(fp, ArgumentsAdaptorFrameConstants::kLengthOffset));
+
+  __ LeaveFrame(StackFrame::ARGUMENTS_ADAPTOR);
+  __ add(sp, sp, Operand::PointerOffsetFromSmiKey(r1));
+  __ add(sp, sp, Operand(kPointerSize));  // adjust for receiver
+}
+
 // static
 // TODO(v8:11615): Observe Code::kMaxArguments in CallOrConstructVarargs
 void Builtins::Generate_CallOrConstructVarargs(MacroAssembler* masm,
@@ -2086,8 +2097,31 @@ void Builtins::Generate_CallOrConstructForwardVarargs(MacroAssembler* masm,
     __ bind(&new_target_constructor);
   }
 
+  // Check if we have an arguments adaptor frame below the function frame.
+  Label arguments_adaptor, arguments_done;
+  __ ldr(r4, MemOperand(fp, StandardFrameConstants::kCallerFPOffset));
+  __ ldr(scratch,
+         MemOperand(r4, CommonFrameConstants::kContextOrFrameTypeOffset));
+  __ cmp(scratch,
+         Operand(StackFrame::TypeToMarker(StackFrame::ARGUMENTS_ADAPTOR)));
+  __ b(eq, &arguments_adaptor);
+  {
+    __ ldr(r5, MemOperand(fp, StandardFrameConstants::kFunctionOffset));
+    __ ldr(r5, FieldMemOperand(r5, JSFunction::kSharedFunctionInfoOffset));
+    __ ldrh(r5, FieldMemOperand(
+                    r5, SharedFunctionInfo::kFormalParameterCountOffset));
+    __ mov(r4, fp);
+  }
+  __ b(&arguments_done);
+  __ bind(&arguments_adaptor);
+  {
+    // Load the length from the ArgumentsAdaptorFrame.
+    __ ldr(r5, MemOperand(r4, ArgumentsAdaptorFrameConstants::kLengthOffset));
+    __ SmiUntag(r5);
+  }
+  __ bind(&arguments_done);
+
   Label stack_done, stack_overflow;
-  __ ldr(r5, MemOperand(fp, StandardFrameConstants::kArgCOffset));
   __ sub(r5, r5, r2, SetCC);
   __ b(le, &stack_done);
   {
@@ -2501,6 +2535,184 @@ void Builtins::Generate_Construct(MacroAssembler* masm) {
           RelocInfo::CODE_TARGET);
 }
 
+void Builtins::Generate_ArgumentsAdaptorTrampoline(MacroAssembler* masm) {
+  // ----------- S t a t e -------------
+  //  -- r0 : actual number of arguments
+  //  -- r1 : function (passed through to callee)
+  //  -- r2 : expected number of arguments
+  //  -- r3 : new target (passed through to callee)
+  // -----------------------------------
+
+  Label dont_adapt_arguments, stack_overflow, skip_adapt_arguments;
+  __ cmp(r2, Operand(kDontAdaptArgumentsSentinel));
+  __ b(eq, &dont_adapt_arguments);
+  __ ldr(r4, FieldMemOperand(r1, JSFunction::kSharedFunctionInfoOffset));
+  __ ldr(r4, FieldMemOperand(r4, SharedFunctionInfo::kFlagsOffset));
+
+  // This optimization is disabled when the arguments are reversed.
+  __ tst(r4,
+         Operand(SharedFunctionInfo::IsSafeToSkipArgumentsAdaptorBit::kMask));
+  __ b(ne, &skip_adapt_arguments);
+
+  // -------------------------------------------
+  // Adapt arguments.
+  // -------------------------------------------
+  {
+    Label under_application, over_application, invoke;
+    __ cmp(r0, r2);
+    __ b(lt, &under_application);
+
+    // Enough parameters: actual >= expected
+    __ bind(&over_application);
+    {
+      EnterArgumentsAdaptorFrame(masm);
+      __ StackOverflowCheck(r2, r5, &stack_overflow);
+
+      // Calculate copy start address into r0 and copy end address into r4.
+      // r0: actual number of arguments as a smi
+      // r1: function
+      // r2: expected number of arguments
+      // r3: new target (passed through to callee)
+      __ add(r0, fp, Operand::PointerOffsetFromSmiKey(r0));
+      // adjust for return address and receiver
+      __ add(r0, r0, Operand(2 * kSystemPointerSize));
+      __ sub(r4, r0, Operand(r2, LSL, kSystemPointerSizeLog2));
+
+      // Copy the arguments (including the receiver) to the new stack frame.
+      // r0: copy start address
+      // r1: function
+      // r2: expected number of arguments
+      // r3: new target (passed through to callee)
+      // r4: copy end address
+
+      Label copy;
+      __ bind(&copy);
+      __ ldr(r5, MemOperand(r0, 0));
+      __ push(r5);
+      __ cmp(r0, r4);  // Compare before moving to next argument.
+      __ sub(r0, r0, Operand(kSystemPointerSize));
+      __ b(ne, &copy);
+
+      __ b(&invoke);
+    }
+
+    // Too few parameters: Actual < expected
+    __ bind(&under_application);
+    {
+      EnterArgumentsAdaptorFrame(masm);
+      __ StackOverflowCheck(r2, r5, &stack_overflow);
+
+      // Calculate copy start address into r0 and copy end address is fp.
+      // r0: actual number of arguments as a smi
+      // r1: function
+      // r2: expected number of arguments
+      // r3: new target (passed through to callee)
+      __ add(r0, fp, Operand::PointerOffsetFromSmiKey(r0));
+
+      // Copy the arguments (including the receiver) to the new stack frame.
+      // r0: copy start address
+      // r1: function
+      // r2: expected number of arguments
+      // r3: new target (passed through to callee)
+      Label copy;
+      __ bind(&copy);
+
+      // Adjust load for return address and receiver.
+      __ ldr(r5, MemOperand(r0, 2 * kPointerSize));
+      __ push(r5);
+
+      __ cmp(r0, fp);  // Compare before moving to next argument.
+      __ sub(r0, r0, Operand(kPointerSize));
+      __ b(ne, &copy);
+
+      // Fill the remaining expected arguments with undefined.
+      // r1: function
+      // r2: expected number of arguments
+      // r3: new target (passed through to callee)
+      __ LoadRoot(r5, RootIndex::kUndefinedValue);
+      __ sub(r4, fp, Operand(r2, LSL, kPointerSizeLog2));
+      // Adjust for frame.
+      __ sub(r4, r4,
+             Operand(ArgumentsAdaptorFrameConstants::kFixedFrameSizeFromFp +
+                     kPointerSize));
+
+      Label fill;
+      __ bind(&fill);
+      __ push(r5);
+      __ cmp(sp, r4);
+      __ b(ne, &fill);
+    }
+
+    // Call the entry point.
+    __ bind(&invoke);
+    __ mov(r0, r2);
+    // r0 : expected number of arguments
+    // r1 : function (passed through to callee)
+    // r3 : new target (passed through to callee)
+    static_assert(kJavaScriptCallCodeStartRegister == r2, "ABI mismatch");
+    __ ldr(r2, FieldMemOperand(r1, JSFunction::kCodeOffset));
+    __ CallCodeObject(r2);
+
+    // Store offset of return address for deoptimizer.
+    masm->isolate()->heap()->SetArgumentsAdaptorDeoptPCOffset(
+        masm->pc_offset());
+
+    // Exit frame and return.
+    LeaveArgumentsAdaptorFrame(masm);
+    __ Jump(lr);
+  }
+
+  // -------------------------------------------
+  // Skip adapt arguments.
+  // -------------------------------------------
+  __ bind(&skip_adapt_arguments);
+  {
+    // The callee cannot observe the actual arguments, so it's safe to just
+    // pass the expected arguments by massaging the stack appropriately. See
+    // http://bit.ly/v8-faster-calls-with-arguments-mismatch for details.
+    Label under_application, over_application;
+    __ cmp(r0, r2);
+    __ b(lt, &under_application);
+
+    __ bind(&over_application);
+    {
+      // Remove superfluous parameters from the stack.
+      __ sub(r4, r0, r2);
+      __ mov(r0, r2);
+      __ add(sp, sp, Operand(r4, LSL, kPointerSizeLog2));
+      __ b(&dont_adapt_arguments);
+    }
+
+    __ bind(&under_application);
+    {
+      // Fill remaining expected arguments with undefined values.
+      Label fill;
+      __ LoadRoot(r4, RootIndex::kUndefinedValue);
+      __ bind(&fill);
+      __ add(r0, r0, Operand(1));
+      __ push(r4);
+      __ cmp(r0, r2);
+      __ b(lt, &fill);
+      __ b(&dont_adapt_arguments);
+    }
+  }
+
+  // -------------------------------------------
+  // Dont adapt arguments.
+  // -------------------------------------------
+  __ bind(&dont_adapt_arguments);
+  static_assert(kJavaScriptCallCodeStartRegister == r2, "ABI mismatch");
+  __ ldr(r2, FieldMemOperand(r1, JSFunction::kCodeOffset));
+  __ JumpCodeObject(r2);
+
+  __ bind(&stack_overflow);
+  {
+    FrameScope frame(masm, StackFrame::MANUAL);
+    __ CallRuntime(Runtime::kThrowStackOverflow);
+    __ bkpt(0);
+  }
+}
+
 #if V8_ENABLE_WEBASSEMBLY
 void Builtins::Generate_WasmCompileLazy(MacroAssembler* masm) {
   // The function index was put in a register by the jump table trampoline.
diff --git a/src/builtins/arm64/builtins-arm64.cc b/src/builtins/arm64/builtins-arm64.cc
index ed8a2de0d8..0080ad40ab 100644
--- a/src/builtins/arm64/builtins-arm64.cc
+++ b/src/builtins/arm64/builtins-arm64.cc
@@ -980,21 +980,6 @@ static void LeaveInterpreterFrame(MacroAssembler* masm, Register scratch1,
   __ Ldr(params_size.W(),
          FieldMemOperand(params_size, BytecodeArray::kParameterSizeOffset));
 
-  Register actual_params_size = scratch2;
-  // Compute the size of the actual parameters + receiver (in bytes).
-  __ Ldr(actual_params_size,
-         MemOperand(fp, StandardFrameConstants::kArgCOffset));
-  __ lsl(actual_params_size, actual_params_size, kSystemPointerSizeLog2);
-  __ Add(actual_params_size, actual_params_size, Operand(kSystemPointerSize));
-
-  // If actual is bigger than formal, then we should use it to free up the stack
-  // arguments.
-  Label corrected_args_count;
-  __ Cmp(params_size, actual_params_size);
-  __ B(ge, &corrected_args_count);
-  __ Mov(params_size, actual_params_size);
-  __ Bind(&corrected_args_count);
-
   // Leave the frame (also dropping the register file).
   __ LeaveFrame(StackFrame::INTERPRETED);
 
@@ -2379,6 +2364,30 @@ void Builtins::Generate_ReflectConstruct(MacroAssembler* masm) {
 
 namespace {
 
+void EnterArgumentsAdaptorFrame(MacroAssembler* masm) {
+  __ Push<TurboAssembler::kSignLR>(lr, fp);
+  __ Mov(x11, StackFrame::TypeToMarker(StackFrame::ARGUMENTS_ADAPTOR));
+  __ Push(x11, x1);  // x1: function
+  __ SmiTag(x11, x0);  // x0: number of arguments.
+  __ Push(x11, padreg);
+  __ Add(fp, sp, ArgumentsAdaptorFrameConstants::kFixedFrameSizeFromFp);
+}
+
+void LeaveArgumentsAdaptorFrame(MacroAssembler* masm) {
+  // ----------- S t a t e -------------
+  //  -- x0 : result being passed through
+  // -----------------------------------
+  // Get the number of arguments passed (as a smi), tear down the frame and
+  // then drop the parameters and the receiver.
+  __ Ldr(x10, MemOperand(fp, ArgumentsAdaptorFrameConstants::kLengthOffset));
+  __ Mov(sp, fp);
+  __ Pop<TurboAssembler::kAuthLR>(fp, lr);
+
+  // Drop actual parameters and receiver.
+  __ SmiUntag(x10);
+  __ DropArguments(x10, TurboAssembler::kCountExcludesReceiver);
+}
+
 // Prepares the stack for copying the varargs. First we claim the necessary
 // slots, taking care of potential padding. Then we copy the existing arguments
 // one slot up or one slot down, as needed.
@@ -2546,9 +2555,38 @@ void Builtins::Generate_CallOrConstructForwardVarargs(MacroAssembler* masm,
     __ Bind(&new_target_constructor);
   }
 
+  Register args_fp = x5;
   Register len = x6;
+  {
+    Label arguments_adaptor, arguments_done;
+    Register scratch = x10;
+    __ Ldr(args_fp, MemOperand(fp, StandardFrameConstants::kCallerFPOffset));
+    __ Ldr(x4, MemOperand(args_fp,
+                          CommonFrameConstants::kContextOrFrameTypeOffset));
+    __ CmpTagged(x4, StackFrame::TypeToMarker(StackFrame::ARGUMENTS_ADAPTOR));
+    __ B(eq, &arguments_adaptor);
+    {
+      __ Ldr(scratch, MemOperand(fp, StandardFrameConstants::kFunctionOffset));
+      __ LoadTaggedPointerField(
+          scratch,
+          FieldMemOperand(scratch, JSFunction::kSharedFunctionInfoOffset));
+      __ Ldrh(len,
+              FieldMemOperand(scratch,
+                              SharedFunctionInfo::kFormalParameterCountOffset));
+      __ Mov(args_fp, fp);
+    }
+    __ B(&arguments_done);
+    __ Bind(&arguments_adaptor);
+    {
+      // Just load the length from ArgumentsAdaptorFrame.
+      __ SmiUntag(
+          len,
+          MemOperand(args_fp, ArgumentsAdaptorFrameConstants::kLengthOffset));
+    }
+    __ Bind(&arguments_done);
+  }
+
   Label stack_done, stack_overflow;
-  __ Ldr(len, MemOperand(fp, StandardFrameConstants::kArgCOffset));
   __ Subs(len, len, start_index);
   __ B(le, &stack_done);
   // Check for stack overflow.
@@ -2989,6 +3027,218 @@ void Builtins::Generate_Construct(MacroAssembler* masm) {
           RelocInfo::CODE_TARGET);
 }
 
+void Builtins::Generate_ArgumentsAdaptorTrampoline(MacroAssembler* masm) {
+  ASM_LOCATION("Builtins::Generate_ArgumentsAdaptorTrampoline");
+
+  Register argc_actual = x0;    // Excluding the receiver.
+  Register argc_expected = x2;  // Excluding the receiver.
+  Register function = x1;
+
+  Label create_adaptor_frame, dont_adapt_arguments, stack_overflow;
+
+  __ Cmp(argc_expected, kDontAdaptArgumentsSentinel);
+  __ B(eq, &dont_adapt_arguments);
+
+  // This optimization is disabled when the arguments are reversed.
+  Label adapt_arguments_in_place;
+  Register argc_actual_minus_expected = x5;
+
+  // When the difference between argc_actual and argc_expected is odd, we
+  // create an arguments adaptor frame.
+  __ Sub(argc_actual_minus_expected, argc_actual, argc_expected);
+  __ Tbnz(argc_actual_minus_expected, 0, &create_adaptor_frame);
+
+  // When the difference is even, check if we are allowed to adjust the
+  // existing frame instead.
+  __ LoadTaggedPointerField(
+      x4, FieldMemOperand(x1, JSFunction::kSharedFunctionInfoOffset));
+  __ Ldr(w4, FieldMemOperand(x4, SharedFunctionInfo::kFlagsOffset));
+  __ TestAndBranchIfAnySet(
+      w4, SharedFunctionInfo::IsSafeToSkipArgumentsAdaptorBit::kMask,
+      &adapt_arguments_in_place);
+
+  // -------------------------------------------
+  // Create an arguments adaptor frame.
+  // -------------------------------------------
+  __ Bind(&create_adaptor_frame);
+  {
+    __ RecordComment("-- Adapt arguments --");
+    EnterArgumentsAdaptorFrame(masm);
+
+    Register copy_from = x10;
+    Register copy_to = x12;
+    Register copy_end = x11;
+    Register argc_to_copy = x13;
+    Register scratch1 = x15;
+
+    // We need slots for the expected arguments, with one extra slot for the
+    // receiver.
+    __ RecordComment("-- Stack check --");
+    __ Add(scratch1, argc_expected, 1);
+    __ StackOverflowCheck(scratch1, &stack_overflow);
+
+    // Round up number of slots to be even, to maintain stack alignment.
+    __ RecordComment("-- Allocate callee frame slots --");
+    __ Add(scratch1, scratch1, 1);
+    __ Bic(scratch1, scratch1, 1);
+    __ Claim(scratch1, kSystemPointerSize);
+
+    Register argc_unused_actual = x14;
+    Register scratch2 = x16;
+
+    // Preparing the expected arguments is done in four steps, the order of
+    // which is chosen so we can use LDP/STP and avoid conditional branches as
+    // much as possible.
+
+    __ Mov(copy_to, sp);
+
+    // (1) If we don't have enough arguments, fill the remaining expected
+    // arguments with undefined, otherwise skip this step.
+    Label enough_arguments;
+    __ Subs(scratch1, argc_actual, argc_expected);
+    __ Csel(argc_unused_actual, xzr, scratch1, lt);
+    __ Csel(argc_to_copy, argc_expected, argc_actual, ge);
+    __ B(ge, &enough_arguments);
+
+    // Fill the remaining expected arguments with undefined.
+    __ RecordComment("-- Fill slots with undefined --");
+    __ Sub(copy_end, copy_to, Operand(scratch1, LSL, kSystemPointerSizeLog2));
+    __ LoadRoot(scratch1, RootIndex::kUndefinedValue);
+
+    Label fill;
+    __ Bind(&fill);
+    __ Stp(scratch1, scratch1,
+           MemOperand(copy_to, 2 * kSystemPointerSize, PostIndex));
+    // We might write one slot extra, but that is ok because we'll overwrite it
+    // below.
+    __ Cmp(copy_end, copy_to);
+    __ B(hi, &fill);
+
+    // Correct copy_to, for the case where we wrote one additional slot.
+    __ Mov(copy_to, copy_end);
+
+    __ Bind(&enough_arguments);
+    // (2) Copy all of the actual arguments, or as many as we need.
+    Label skip_copy;
+    __ RecordComment("-- Copy actual arguments --");
+    __ Cbz(argc_to_copy, &skip_copy);
+    __ Add(copy_end, copy_to,
+           Operand(argc_to_copy, LSL, kSystemPointerSizeLog2));
+    __ Add(copy_from, fp, 2 * kSystemPointerSize);
+    // Adjust for difference between actual and expected arguments.
+    __ Add(copy_from, copy_from,
+           Operand(argc_unused_actual, LSL, kSystemPointerSizeLog2));
+
+    // Copy arguments. We use load/store pair instructions, so we might
+    // overshoot by one slot, but since we copy the arguments starting from the
+    // last one, if we do overshoot, the extra slot will be overwritten later by
+    // the receiver.
+    Label copy_2_by_2;
+    __ Bind(&copy_2_by_2);
+    __ Ldp(scratch1, scratch2,
+           MemOperand(copy_from, 2 * kSystemPointerSize, PostIndex));
+    __ Stp(scratch1, scratch2,
+           MemOperand(copy_to, 2 * kSystemPointerSize, PostIndex));
+    __ Cmp(copy_end, copy_to);
+    __ B(hi, &copy_2_by_2);
+    __ Bind(&skip_copy);
+
+    // (3) Store padding, which might be overwritten by the receiver, if it is
+    // not necessary.
+    __ RecordComment("-- Store padding --");
+    __ Str(padreg, MemOperand(fp, -5 * kSystemPointerSize));
+
+    // (4) Store receiver. Calculate target address from the sp to avoid
+    // checking for padding. Storing the receiver will overwrite either the
+    // extra slot we copied with the actual arguments, if we did copy one, or
+    // the padding we stored above.
+    __ RecordComment("-- Store receiver --");
+    __ Add(copy_from, fp, 2 * kSystemPointerSize);
+    __ Ldr(scratch1,
+           MemOperand(copy_from, argc_actual, LSL, kSystemPointerSizeLog2));
+    __ Str(scratch1,
+           MemOperand(sp, argc_expected, LSL, kSystemPointerSizeLog2));
+
+    // Arguments have been adapted. Now call the entry point.
+    __ RecordComment("-- Call entry point --");
+    __ Mov(argc_actual, argc_expected);
+    // x0 : expected number of arguments
+    // x1 : function (passed through to callee)
+    // x3 : new target (passed through to callee)
+    static_assert(kJavaScriptCallCodeStartRegister == x2, "ABI mismatch");
+    __ LoadTaggedPointerField(
+        x2, FieldMemOperand(function, JSFunction::kCodeOffset));
+    __ CallCodeObject(x2);
+
+    // Store offset of return address for deoptimizer.
+    masm->isolate()->heap()->SetArgumentsAdaptorDeoptPCOffset(
+        masm->pc_offset());
+
+    // Exit frame and return.
+    LeaveArgumentsAdaptorFrame(masm);
+    __ Ret();
+  }
+
+  // -----------------------------------------
+  // Adapt arguments in the existing frame.
+  // -----------------------------------------
+  __ Bind(&adapt_arguments_in_place);
+  {
+    __ RecordComment("-- Update arguments in place --");
+    // The callee cannot observe the actual arguments, so it's safe to just
+    // pass the expected arguments by massaging the stack appropriately. See
+    // http://bit.ly/v8-faster-calls-with-arguments-mismatch for details.
+    Label under_application, over_application;
+    __ Tbnz(argc_actual_minus_expected, kXSignBit, &under_application);
+
+    __ Bind(&over_application);
+    {
+      // Remove superfluous arguments from the stack. The number of superflous
+      // arguments is even.
+      __ RecordComment("-- Over-application --");
+      __ Mov(argc_actual, argc_expected);
+      __ Drop(argc_actual_minus_expected);
+      __ B(&dont_adapt_arguments);
+    }
+
+    __ Bind(&under_application);
+    {
+      // Fill remaining expected arguments with undefined values.
+      __ RecordComment("-- Under-application --");
+      Label fill;
+      Register undef_value = x16;
+      __ LoadRoot(undef_value, RootIndex::kUndefinedValue);
+      __ Bind(&fill);
+      __ Add(argc_actual, argc_actual, 2);
+      __ Push(undef_value, undef_value);
+      __ Cmp(argc_actual, argc_expected);
+      __ B(lt, &fill);
+      __ B(&dont_adapt_arguments);
+    }
+  }
+
+  // -------------------------------------------
+  // Dont adapt arguments.
+  // -------------------------------------------
+  __ Bind(&dont_adapt_arguments);
+  {
+    // Call the entry point without adapting the arguments.
+    __ RecordComment("-- Call without adapting args --");
+    static_assert(kJavaScriptCallCodeStartRegister == x2, "ABI mismatch");
+    __ LoadTaggedPointerField(
+        x2, FieldMemOperand(function, JSFunction::kCodeOffset));
+    __ JumpCodeObject(x2);
+  }
+
+  __ Bind(&stack_overflow);
+  __ RecordComment("-- Stack overflow --");
+  {
+    FrameScope frame(masm, StackFrame::MANUAL);
+    __ CallRuntime(Runtime::kThrowStackOverflow);
+    __ Unreachable();
+  }
+}
+
 #if V8_ENABLE_WEBASSEMBLY
 void Builtins::Generate_WasmCompileLazy(MacroAssembler* masm) {
   // The function index was put in w8 by the jump table trampoline.
@@ -3927,10 +4177,6 @@ void Generate_DeoptimizationEntry(MacroAssembler* masm,
   __ Lsr(unwind_limit, unwind_limit, kSystemPointerSizeLog2);
   __ Mov(x5, unwind_limit);
   __ CopyDoubleWords(x3, x1, x5);
-  // Since {unwind_limit} is the frame size up to the parameter count, we might
-  // end up with a unaligned stack pointer. This is later recovered when
-  // setting the stack pointer to {caller_frame_top_offset}.
-  __ Bic(unwind_limit, unwind_limit, 1);
   __ Drop(unwind_limit);
 
   // Compute the output frame in the deoptimizer.
diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.h
index 70eb349dab..b1f1fd7c53 100644
--- a/src/builtins/builtins-definitions.h
+++ b/src/builtins/builtins-definitions.h
@@ -60,6 +60,7 @@ namespace internal {
   TFC(AdaptorWithBuiltinExitFrame, CppBuiltinAdaptor)                          \
                                                                                \
   /* Calls */                                                                  \
+  ASM(ArgumentsAdaptorTrampoline, ArgumentsAdaptor)                            \
   /* ES6 section 9.2.1 [[Call]] ( thisArgument, argumentsList) */              \
   ASM(CallFunction_ReceiverIsNullOrUndefined, CallTrampoline)                  \
   ASM(CallFunction_ReceiverIsNotNullOrUndefined, CallTrampoline)               \
diff --git a/src/builtins/builtins-internal-gen.cc b/src/builtins/builtins-internal-gen.cc
index 49ad4b4e7c..b20968e52c 100644
--- a/src/builtins/builtins-internal-gen.cc
+++ b/src/builtins/builtins-internal-gen.cc
@@ -891,26 +891,6 @@ TF_BUILTIN(AdaptorWithBuiltinExitFrame, CodeStubAssembler) {
 
   TVARIABLE(Int32T, pushed_argc, actual_argc);
 
-  TNode<SharedFunctionInfo> shared = LoadJSFunctionSharedFunctionInfo(target);
-
-  TNode<Int32T> formal_count =
-      UncheckedCast<Int32T>(LoadSharedFunctionInfoFormalParameterCount(shared));
-
-  // The number of arguments pushed is the maximum of actual arguments count
-  // and formal parameters count. Except when the formal parameters count is
-  // the sentinel.
-  Label check_argc(this), update_argc(this), done_argc(this);
-
-  Branch(Word32Equal(formal_count, Int32Constant(kDontAdaptArgumentsSentinel)),
-         &done_argc, &check_argc);
-  BIND(&check_argc);
-  Branch(Int32GreaterThan(formal_count, pushed_argc.value()), &update_argc,
-         &done_argc);
-  BIND(&update_argc);
-  pushed_argc = formal_count;
-  Goto(&done_argc);
-  BIND(&done_argc);
-
   // Update arguments count for CEntry to contain the number of arguments
   // including the receiver and the extra arguments.
   TNode<Int32T> argc = Int32Add(
@@ -1239,20 +1219,6 @@ TF_BUILTIN(InstantiateAsmJs, CodeStubAssembler) {
   TNode<Object> maybe_result_or_smi_zero = CallRuntime(
       Runtime::kInstantiateAsmJs, context, function, stdlib, foreign, heap);
   GotoIf(TaggedIsSmi(maybe_result_or_smi_zero), &tailcall_to_function);
-
-  TNode<SharedFunctionInfo> shared = LoadJSFunctionSharedFunctionInfo(function);
-  TNode<Int32T> parameter_count =
-      UncheckedCast<Int32T>(LoadSharedFunctionInfoFormalParameterCount(shared));
-  // This builtin intercepts a call to {function}, where the number of arguments
-  // pushed is the maximum of actual arguments count and formal parameters
-  // count.
-  Label argc_lt_param_count(this), argc_ge_param_count(this);
-  Branch(IntPtrLessThan(args.GetLength(), ChangeInt32ToIntPtr(parameter_count)),
-         &argc_lt_param_count, &argc_ge_param_count);
-  BIND(&argc_lt_param_count);
-  PopAndReturn(Int32Add(parameter_count, Int32Constant(1)),
-               maybe_result_or_smi_zero);
-  BIND(&argc_ge_param_count);
   args.PopAndReturn(maybe_result_or_smi_zero);
 
   BIND(&tailcall_to_function);
diff --git a/src/builtins/builtins.cc b/src/builtins/builtins.cc
index e2d3acef36..e21fe1aa0a 100644
--- a/src/builtins/builtins.cc
+++ b/src/builtins/builtins.cc
@@ -494,6 +494,7 @@ bool Builtins::CodeObjectIsExecutable(Builtin builtin) {
     case Builtin::kCall_ReceiverIsNullOrUndefined:
     case Builtin::kCall_ReceiverIsNotNullOrUndefined:
     case Builtin::kCall_ReceiverIsAny:
+    case Builtin::kArgumentsAdaptorTrampoline:
     case Builtin::kHandleApiCall:
     case Builtin::kInstantiateAsmJs:
 #if V8_ENABLE_WEBASSEMBLY
diff --git a/src/builtins/frame-arguments.tq b/src/builtins/frame-arguments.tq
index 5f25c97dc3..27f3266e2d 100644
--- a/src/builtins/frame-arguments.tq
+++ b/src/builtins/frame-arguments.tq
@@ -11,6 +11,8 @@ struct Arguments {
 
 extern operator '[]' macro GetArgumentValue(Arguments, intptr): JSAny;
 extern macro GetFrameArguments(FrameWithArguments, intptr): Arguments;
+const kNoArgumentsAdaptor:
+    constexpr bool generates 'kNoArgumentsAdaptor';
 
 struct ArgumentsIterator {
   macro Next(): Object labels NoMore {
@@ -47,13 +49,30 @@ macro GetFrameWithArgumentsInfo(implicit context: Context)():
   const shared: SharedFunctionInfo = f.shared_function_info;
   const formalParameterCount: bint =
       Convert<bint>(Convert<int32>(shared.formal_parameter_count));
-  // TODO(victorgomes): When removing the v8_disable_arguments_adaptor flag,
-  // FrameWithArgumentsInfo can be simplified, since the frame field already
-  // contains the argument count.
-  const argumentCount: bint = Convert<bint>(frame.argument_count);
-  return FrameWithArgumentsInfo{
-    frame,
-    argument_count: argumentCount,
-    formal_parameter_count: formalParameterCount
-  };
+  if constexpr (kNoArgumentsAdaptor) {
+    // TODO(victorgomes): When removing the v8_disable_arguments_adaptor flag,
+    // FrameWithArgumentsInfo can be simplified, since the frame field already
+    // contains the argument count.
+    const argumentCount: bint = Convert<bint>(frame.argument_count);
+    return FrameWithArgumentsInfo{
+      frame,
+      argument_count: argumentCount,
+      formal_parameter_count: formalParameterCount
+    };
+  } else {
+    const argumentCount: bint = formalParameterCount;
+
+    const adaptor = Cast<ArgumentsAdaptorFrame>(frame.caller)
+        otherwise return FrameWithArgumentsInfo{
+      frame,
+      argument_count: argumentCount,
+      formal_parameter_count: formalParameterCount
+    };
+
+    return FrameWithArgumentsInfo{
+      frame: adaptor,
+      argument_count: Convert<bint>(adaptor.length),
+      formal_parameter_count: formalParameterCount
+    };
+  }
 }
diff --git a/src/builtins/frames.tq b/src/builtins/frames.tq
index 03336bd464..3b716b7a64 100644
--- a/src/builtins/frames.tq
+++ b/src/builtins/frames.tq
@@ -3,6 +3,8 @@
 // found in the LICENSE file.
 
 type FrameType extends Smi constexpr 'StackFrame::Type';
+const ARGUMENTS_ADAPTOR_FRAME: constexpr FrameType
+    generates 'StackFrame::ARGUMENTS_ADAPTOR';
 const STUB_FRAME: constexpr FrameType
     generates 'StackFrame::STUB';
 const kFrameTypeCount:
@@ -29,8 +31,9 @@ Cast<FrameType>(o: Object): FrameType
 
 type FrameBase extends RawPtr constexpr 'void*';
 type StandardFrame extends FrameBase constexpr 'void*';
+type ArgumentsAdaptorFrame extends FrameBase constexpr 'void*';
 type StubFrame extends FrameBase constexpr 'void*';
-type FrameWithArguments = StandardFrame;
+type FrameWithArguments = StandardFrame|ArgumentsAdaptorFrame;
 type Frame = FrameWithArguments|StubFrame;
 
 extern macro LoadFramePointer(): Frame;
@@ -43,6 +46,9 @@ macro LoadObjectFromFrame(f: Frame, o: constexpr int32): Object {
 macro LoadPointerFromFrame(f: Frame, o: constexpr int32): RawPtr {
   return LoadBufferPointer(f, o);
 }
+macro LoadSmiFromFrame(f: Frame, o: constexpr int32): Smi {
+  return LoadBufferSmi(f, o);
+}
 macro LoadIntptrFromFrame(f: Frame, o: constexpr int32): intptr {
   return LoadBufferIntptr(f, o);
 }
@@ -96,6 +102,14 @@ macro LoadContextOrFrameTypeFromFrame(implicit context: Context)(f: Frame):
       LoadObjectFromFrame(f, kStandardFrameContextOrFrameTypeOffset));
 }
 
+const kArgumentsAdaptorFrameLengthOffset: constexpr int31
+    generates 'ArgumentsAdaptorFrameConstants::kLengthOffset';
+operator '.length'
+macro LoadLengthFromAdapterFrame(implicit context: Context)(
+    f: ArgumentsAdaptorFrame): Smi {
+  return LoadSmiFromFrame(f, kArgumentsAdaptorFrameLengthOffset);
+}
+
 operator '==' macro FrameTypeEquals(f1: FrameType, f2: FrameType): bool {
   return TaggedEqual(f1, f2);
 }
@@ -121,6 +135,16 @@ Cast<StandardFrame>(implicit context: Context)(f: Frame):
   goto CastError;
 }
 
+Cast<ArgumentsAdaptorFrame>(implicit context: Context)(f: Frame):
+    ArgumentsAdaptorFrame labels CastError {
+  const t: FrameType =
+      Cast<FrameType>(f.context_or_frame_type) otherwise CastError;
+  if (t == ARGUMENTS_ADAPTOR_FRAME) {
+    return %RawDownCast<ArgumentsAdaptorFrame>(f);
+  }
+  goto CastError;
+}
+
 // Load target function from the current JS frame.
 // This is an alternative way of getting the target function in addition to
 // Parameter(Descriptor::kJSTarget). The latter should be used near the
diff --git a/src/builtins/ia32/builtins-ia32.cc b/src/builtins/ia32/builtins-ia32.cc
index 00da0a0089..945bcf050d 100644
--- a/src/builtins/ia32/builtins-ia32.cc
+++ b/src/builtins/ia32/builtins-ia32.cc
@@ -749,21 +749,6 @@ static void LeaveInterpreterFrame(MacroAssembler* masm, Register scratch1,
   __ mov(params_size,
          FieldOperand(params_size, BytecodeArray::kParameterSizeOffset));
 
-  Register actual_params_size = scratch2;
-  // Compute the size of the actual parameters + receiver (in bytes).
-  __ mov(actual_params_size, Operand(ebp, StandardFrameConstants::kArgCOffset));
-  __ lea(actual_params_size,
-         Operand(actual_params_size, times_system_pointer_size,
-                 kSystemPointerSize));
-
-  // If actual is bigger than formal, then we should use it to free up the stack
-  // arguments.
-  Label corrected_args_count;
-  __ cmp(params_size, actual_params_size);
-  __ j(greater_equal, &corrected_args_count, Label::kNear);
-  __ mov(params_size, actual_params_size);
-  __ bind(&corrected_args_count);
-
   // Leave the frame (also dropping the register file).
   __ leave();
 
@@ -2082,6 +2067,41 @@ void Builtins::Generate_ReflectConstruct(MacroAssembler* masm) {
           RelocInfo::CODE_TARGET);
 }
 
+static void EnterArgumentsAdaptorFrame(MacroAssembler* masm) {
+  __ push(ebp);
+  __ mov(ebp, esp);
+
+  // Store the arguments adaptor context sentinel.
+  __ push(Immediate(StackFrame::TypeToMarker(StackFrame::ARGUMENTS_ADAPTOR)));
+
+  // Push the function on the stack.
+  __ push(edi);
+
+  // Preserve the number of arguments on the stack. Must preserve eax,
+  // ebx and ecx because these registers are used when copying the
+  // arguments and the receiver.
+  STATIC_ASSERT(kSmiTagSize == 1);
+  __ lea(edi, Operand(eax, eax, times_1, kSmiTag));
+  __ push(edi);
+
+  __ Push(Immediate(0));  // Padding.
+}
+
+static void LeaveArgumentsAdaptorFrame(MacroAssembler* masm) {
+  // Retrieve the number of arguments from the stack.
+  __ mov(edi, Operand(ebp, ArgumentsAdaptorFrameConstants::kLengthOffset));
+
+  // Leave the frame.
+  __ leave();
+
+  // Remove caller arguments from the stack.
+  STATIC_ASSERT(kSmiTagSize == 1 && kSmiTag == 0);
+  __ PopReturnAddressTo(ecx);
+  __ lea(esp, Operand(esp, edi, times_half_system_pointer_size,
+                      1 * kSystemPointerSize));  // 1 ~ receiver
+  __ PushReturnAddressFrom(ecx);
+}
+
 // static
 // TODO(v8:11615): Observe Code::kMaxArguments in CallOrConstructVarargs
 void Builtins::Generate_CallOrConstructVarargs(MacroAssembler* masm,
@@ -2209,8 +2229,30 @@ void Builtins::Generate_CallOrConstructForwardVarargs(MacroAssembler* masm,
 
   __ movd(xmm1, edx);  // Preserve new.target (in case of [[Construct]]).
 
+  // Check if we have an arguments adaptor frame below the function frame.
+  Label arguments_adaptor, arguments_done;
+  __ mov(scratch, Operand(ebp, StandardFrameConstants::kCallerFPOffset));
+  __ cmp(Operand(scratch, CommonFrameConstants::kContextOrFrameTypeOffset),
+         Immediate(StackFrame::TypeToMarker(StackFrame::ARGUMENTS_ADAPTOR)));
+  __ j(equal, &arguments_adaptor, Label::kNear);
+  {
+    __ mov(edx, Operand(ebp, StandardFrameConstants::kFunctionOffset));
+    __ mov(edx, FieldOperand(edx, JSFunction::kSharedFunctionInfoOffset));
+    __ movzx_w(edx, FieldOperand(
+                        edx, SharedFunctionInfo::kFormalParameterCountOffset));
+    __ mov(scratch, ebp);
+  }
+  __ jmp(&arguments_done, Label::kNear);
+  __ bind(&arguments_adaptor);
+  {
+    // Just load the length from the ArgumentsAdaptorFrame.
+    __ mov(edx,
+           Operand(scratch, ArgumentsAdaptorFrameConstants::kLengthOffset));
+    __ SmiUntag(edx);
+  }
+  __ bind(&arguments_done);
+
   Label stack_done, stack_overflow;
-  __ mov(edx, Operand(ebp, StandardFrameConstants::kArgCOffset));
   __ sub(edx, ecx);
   __ j(less_equal, &stack_done);
   {
@@ -2658,6 +2700,118 @@ void Builtins::Generate_Construct(MacroAssembler* masm) {
           RelocInfo::CODE_TARGET);
 }
 
+void Builtins::Generate_ArgumentsAdaptorTrampoline(MacroAssembler* masm) {
+  // ----------- S t a t e -------------
+  //  -- eax : actual number of arguments
+  //  -- ecx : expected number of arguments
+  //  -- edx : new target (passed through to callee)
+  //  -- edi : function (passed through to callee)
+  // -----------------------------------
+
+  const Register kExpectedNumberOfArgumentsRegister = ecx;
+
+  Label invoke, dont_adapt_arguments, stack_overflow, enough, too_few;
+  __ cmp(kExpectedNumberOfArgumentsRegister, kDontAdaptArgumentsSentinel);
+  __ j(equal, &dont_adapt_arguments);
+  __ cmp(eax, kExpectedNumberOfArgumentsRegister);
+  __ j(less, &too_few);
+
+  {  // Enough parameters: Actual >= expected.
+    __ bind(&enough);
+    EnterArgumentsAdaptorFrame(masm);
+    // edi is used as a scratch register. It should be restored from the frame
+    // when needed.
+    __ StackOverflowCheck(kExpectedNumberOfArgumentsRegister, edi, &stack_overflow);
+
+    // Copy receiver and all expected arguments.
+    const int offset = StandardFrameConstants::kCallerSPOffset;
+    __ lea(edi, Operand(ebp, eax, times_system_pointer_size, offset));
+    __ mov(eax, -1);  // account for receiver
+
+    Label copy;
+    __ bind(&copy);
+    __ inc(eax);
+    __ push(Operand(edi, 0));
+    __ sub(edi, Immediate(kSystemPointerSize));
+    __ cmp(eax, kExpectedNumberOfArgumentsRegister);
+    __ j(less, &copy);
+    // eax now contains the expected number of arguments.
+    __ jmp(&invoke);
+  }
+
+  {  // Too few parameters: Actual < expected.
+    __ bind(&too_few);
+    EnterArgumentsAdaptorFrame(masm);
+    // edi is used as a scratch register. It should be restored from the frame
+    // when needed.
+    __ StackOverflowCheck(kExpectedNumberOfArgumentsRegister, edi, &stack_overflow);
+
+    // Remember expected arguments in xmm0.
+    __ movd(xmm0, kExpectedNumberOfArgumentsRegister);
+
+    // Copy receiver and all actual arguments.
+    const int offset = StandardFrameConstants::kCallerSPOffset;
+    __ lea(edi, Operand(ebp, eax, times_system_pointer_size, offset));
+    // ecx = expected - actual.
+    __ sub(kExpectedNumberOfArgumentsRegister, eax);
+    // eax = -actual - 1
+    __ neg(eax);
+    __ sub(eax, Immediate(1));
+
+    Label copy;
+    __ bind(&copy);
+    __ inc(eax);
+    __ push(Operand(edi, 0));
+    __ sub(edi, Immediate(kSystemPointerSize));
+    __ test(eax, eax);
+    __ j(not_zero, &copy);
+
+    // Fill remaining expected arguments with undefined values.
+    Label fill;
+    __ bind(&fill);
+    __ inc(eax);
+    __ Push(Immediate(masm->isolate()->factory()->undefined_value()));
+    __ cmp(eax, kExpectedNumberOfArgumentsRegister);
+    __ j(less, &fill);
+
+    // Restore expected arguments.
+    __ movd(eax, xmm0);
+  }
+
+  // Call the entry point.
+  __ bind(&invoke);
+  // Restore function pointer.
+  __ mov(edi, Operand(ebp, ArgumentsAdaptorFrameConstants::kFunctionOffset));
+  // eax : expected number of arguments
+  // edx : new target (passed through to callee)
+  // edi : function (passed through to callee)
+  static_assert(kJavaScriptCallCodeStartRegister == ecx, "ABI mismatch");
+  __ mov(ecx, FieldOperand(edi, JSFunction::kCodeOffset));
+  __ CallCodeObject(ecx);
+
+  // Store offset of return address for deoptimizer.
+  masm->isolate()->heap()->SetArgumentsAdaptorDeoptPCOffset(masm->pc_offset());
+
+  // Leave frame and return.
+  LeaveArgumentsAdaptorFrame(masm);
+  __ ret(0);
+
+  // -------------------------------------------
+  // Dont adapt arguments.
+  // -------------------------------------------
+  __ bind(&dont_adapt_arguments);
+  static_assert(kJavaScriptCallCodeStartRegister == ecx, "ABI mismatch");
+  __ mov(ecx, FieldOperand(edi, JSFunction::kCodeOffset));
+  __ JumpCodeObject(ecx);
+
+  __ bind(&stack_overflow);
+  {
+    FrameScope frame(masm, StackFrame::MANUAL);
+    __ CallRuntime(Runtime::kThrowStackOverflow);
+    __ int3();
+  }
+}
+
 namespace {
 
 void Generate_OSREntry(MacroAssembler* masm, Register entry_address) {
diff --git a/src/builtins/x64/builtins-x64.cc b/src/builtins/x64/builtins-x64.cc
index c3267e1d73..f79a560b2a 100644
--- a/src/builtins/x64/builtins-x64.cc
+++ b/src/builtins/x64/builtins-x64.cc
@@ -851,22 +851,6 @@ static void LeaveInterpreterFrame(MacroAssembler* masm, Register scratch1,
   __ movl(params_size,
           FieldOperand(params_size, BytecodeArray::kParameterSizeOffset));
 
-  Register actual_params_size = scratch2;
-  // Compute the size of the actual parameters + receiver (in bytes).
-  __ movq(actual_params_size,
-          Operand(rbp, StandardFrameConstants::kArgCOffset));
-  __ leaq(actual_params_size,
-          Operand(actual_params_size, times_system_pointer_size,
-                  kSystemPointerSize));
-
-  // If actual is bigger than formal, then we should use it to free up the stack
-  // arguments.
-  Label corrected_args_count;
-  __ cmpq(params_size, actual_params_size);
-  __ j(greater_equal, &corrected_args_count, Label::kNear);
-  __ movq(params_size, actual_params_size);
-  __ bind(&corrected_args_count);
-
   // Leave the frame (also dropping the register file).
   __ leave();
 
@@ -2048,6 +2032,185 @@ void Builtins::Generate_ReflectConstruct(MacroAssembler* masm) {
           RelocInfo::CODE_TARGET);
 }
 
+static void EnterArgumentsAdaptorFrame(MacroAssembler* masm) {
+  __ pushq(rbp);
+  __ movq(rbp, rsp);
+
+  // Store the arguments adaptor context sentinel.
+  __ Push(Immediate(StackFrame::TypeToMarker(StackFrame::ARGUMENTS_ADAPTOR)));
+
+  // Push the function on the stack.
+  __ Push(rdi);
+
+  // Preserve the number of arguments on the stack. Must preserve rax,
+  // rbx and rcx because these registers are used when copying the
+  // arguments and the receiver.
+  __ SmiTag(r8, rax);
+  __ Push(r8);
+
+  __ Push(Immediate(0));  // Padding.
+}
+
+static void LeaveArgumentsAdaptorFrame(MacroAssembler* masm) {
+  // Retrieve the number of arguments from the stack. Number is a Smi.
+  __ movq(rbx, Operand(rbp, ArgumentsAdaptorFrameConstants::kLengthOffset));
+
+  // Leave the frame.
+  __ movq(rsp, rbp);
+  __ popq(rbp);
+
+  // Remove caller arguments from the stack.
+  __ PopReturnAddressTo(rcx);
+  SmiIndex index = masm->SmiToIndex(rbx, rbx, kSystemPointerSizeLog2);
+  __ leaq(rsp, Operand(rsp, index.reg, index.scale, 1 * kSystemPointerSize));
+  __ PushReturnAddressFrom(rcx);
+}
+
+void Builtins::Generate_ArgumentsAdaptorTrampoline(MacroAssembler* masm) {
+  // ----------- S t a t e -------------
+  //  -- rax : actual number of arguments
+  //  -- rbx : expected number of arguments
+  //  -- rdx : new target (passed through to callee)
+  //  -- rdi : function (passed through to callee)
+  // -----------------------------------
+
+  Label dont_adapt_arguments, stack_overflow, skip_adapt_arguments;
+  __ cmpq(rbx, Immediate(kDontAdaptArgumentsSentinel));
+  __ j(equal, &dont_adapt_arguments);
+  __ LoadTaggedPointerField(
+      rcx, FieldOperand(rdi, JSFunction::kSharedFunctionInfoOffset));
+
+  // This optimization is disabled when the arguments are reversed.
+  __ testl(
+      FieldOperand(rcx, SharedFunctionInfo::kFlagsOffset),
+      Immediate(SharedFunctionInfo::IsSafeToSkipArgumentsAdaptorBit::kMask));
+  __ j(not_zero, &skip_adapt_arguments);
+
+  // -------------------------------------------
+  // Adapt arguments.
+  // -------------------------------------------
+  {
+    EnterArgumentsAdaptorFrame(masm);
+    Label under_application, over_application, invoke;
+    __ cmpq(rax, rbx);
+    __ j(less, &under_application, Label::kNear);
+
+    // Enough parameters: Actual >= expected.
+    __ bind(&over_application);
+    {
+      // Copy receiver and all expected arguments.
+      const int offset = StandardFrameConstants::kCallerSPOffset;
+      __ leaq(r8, Operand(rbp, rax, times_system_pointer_size, offset));
+      __ Move(rax, -1);  // account for receiver
+
+      Label copy;
+      __ bind(&copy);
+      __ incq(rax);
+      __ Push(Operand(r8, 0));
+      __ subq(r8, Immediate(kSystemPointerSize));
+      __ cmpq(rax, rbx);
+      __ j(less, &copy);
+      __ jmp(&invoke, Label::kNear);
+    }
+
+    // Too few parameters: Actual < expected.
+    __ bind(&under_application);
+    {
+        // Copy receiver and all actual arguments.
+      const int offset = StandardFrameConstants::kCallerSPOffset;
+      __ leaq(r9, Operand(rbp, rax, times_system_pointer_size, offset));
+      __ Move(r8, -1);  // account for receiver
+
+      Label copy;
+      __ bind(&copy);
+      __ incq(r8);
+      __ Push(Operand(r9, 0));
+      __ subq(r9, Immediate(kSystemPointerSize));
+      __ cmpq(r8, rax);
+      __ j(less, &copy);
+
+      // Fill remaining expected arguments with undefined values.
+      Label fill;
+      __ LoadRoot(kScratchRegister, RootIndex::kUndefinedValue);
+      __ bind(&fill);
+      __ incq(rax);
+      __ Push(kScratchRegister);
+      __ cmpq(rax, rbx);
+      __ j(less, &fill);
+    }
+
+    // Call the entry point.
+    __ bind(&invoke);
+    // rax : expected number of arguments
+    // rdx : new target (passed through to callee)
+    // rdi : function (passed through to callee)
+    static_assert(kJavaScriptCallCodeStartRegister == rcx, "ABI mismatch");
+    __ LoadTaggedPointerField(rcx, FieldOperand(rdi, JSFunction::kCodeOffset));
+    __ CallCodeObject(rcx);
+
+    // Store offset of return address for deoptimizer.
+    masm->isolate()->heap()->SetArgumentsAdaptorDeoptPCOffset(
+        masm->pc_offset());
+
+    // Leave frame and return.
+    LeaveArgumentsAdaptorFrame(masm);
+    __ ret(0);
+  }
+
+  // -------------------------------------------
+  // Skip adapt arguments.
+  // -------------------------------------------
+  __ bind(&skip_adapt_arguments);
+  {
+    // The callee cannot observe the actual arguments, so it's safe to just
+    // pass the expected arguments by massaging the stack appropriately. See
+    // http://bit.ly/v8-faster-calls-with-arguments-mismatch for details.
+    Label under_application, over_application, invoke;
+    __ PopReturnAddressTo(rcx);
+    __ cmpq(rax, rbx);
+    __ j(less, &under_application, Label::kNear);
+
+    __ bind(&over_application);
+    {
+      // Remove superfluous parameters from the stack.
+      __ xchgq(rax, rbx);
+      __ subq(rbx, rax);
+      __ leaq(rsp, Operand(rsp, rbx, times_system_pointer_size, 0));
+      __ jmp(&invoke, Label::kNear);
+    }
+
+    __ bind(&under_application);
+    {
+      // Fill remaining expected arguments with undefined values.
+      Label fill;
+      __ LoadRoot(kScratchRegister, RootIndex::kUndefinedValue);
+      __ bind(&fill);
+      __ incq(rax);
+      __ Push(kScratchRegister);
+      __ cmpq(rax, rbx);
+      __ j(less, &fill);
+    }
+
+    __ bind(&invoke);
+    __ PushReturnAddressFrom(rcx);
+  }
+
+  // -------------------------------------------
+  // Don't adapt arguments.
+  // -------------------------------------------
+  __ bind(&dont_adapt_arguments);
+  static_assert(kJavaScriptCallCodeStartRegister == rcx, "ABI mismatch");
+  __ LoadTaggedPointerField(rcx, FieldOperand(rdi, JSFunction::kCodeOffset));
+  __ JumpCodeObject(rcx);
+
+  __ bind(&stack_overflow);
+  {
+    FrameScope frame(masm, StackFrame::MANUAL);
+    __ CallRuntime(Runtime::kThrowStackOverflow);
+    __ int3();
+  }
+}
+
 // static
 // TODO(v8:11615): Observe Code::kMaxArguments in CallOrConstructVarargs
 void Builtins::Generate_CallOrConstructVarargs(MacroAssembler* masm,
@@ -2144,8 +2307,29 @@ void Builtins::Generate_CallOrConstructForwardVarargs(MacroAssembler* masm,
     __ bind(&new_target_constructor);
   }
 
+  // Check if we have an arguments adaptor frame below the function frame.
+  Label arguments_adaptor, arguments_done;
+  __ movq(rbx, Operand(rbp, StandardFrameConstants::kCallerFPOffset));
+  __ cmpq(Operand(rbx, CommonFrameConstants::kContextOrFrameTypeOffset),
+          Immediate(StackFrame::TypeToMarker(StackFrame::ARGUMENTS_ADAPTOR)));
+  __ j(equal, &arguments_adaptor, Label::kNear);
+  {
+    __ movq(r8, Operand(rbp, StandardFrameConstants::kFunctionOffset));
+    __ LoadTaggedPointerField(
+        r8, FieldOperand(r8, JSFunction::kSharedFunctionInfoOffset));
+    __ movzxwq(
+        r8, FieldOperand(r8, SharedFunctionInfo::kFormalParameterCountOffset));
+    __ movq(rbx, rbp);
+  }
+  __ jmp(&arguments_done, Label::kNear);
+  __ bind(&arguments_adaptor);
+  {
+    __ SmiUntag(r8,
+                Operand(rbx, ArgumentsAdaptorFrameConstants::kLengthOffset));
+  }
+  __ bind(&arguments_done);
+
   Label stack_done, stack_overflow;
-  __ movq(r8, Operand(rbp, StandardFrameConstants::kArgCOffset));
   __ subl(r8, rcx);
   __ j(less_equal, &stack_done);
   {
@@ -2326,7 +2510,6 @@ void Generate_PushBoundArguments(MacroAssembler* masm) {
     //  -- rbx : the number of [[BoundArguments]] (checked to be non-zero)
     // -----------------------------------
 
-    // TODO(victor): Use Generate_StackOverflowCheck here.
     // Check the stack for overflow.
     {
       Label done;
diff --git a/src/codegen/arm/interface-descriptors-arm-inl.h b/src/codegen/arm/interface-descriptors-arm-inl.h
index 83d82fe3ce..395c59e9ac 100644
--- a/src/codegen/arm/interface-descriptors-arm-inl.h
+++ b/src/codegen/arm/interface-descriptors-arm-inl.h
@@ -224,6 +224,14 @@ constexpr auto BinaryOp_BaselineDescriptor::registers() {
   return RegisterArray(r1, r0, r2);
 }
 
+// static
+constexpr auto ArgumentsAdaptorDescriptor::registers() {
+  return RegisterArray(r1,   // JSFunction
+                       r3,   // the new target
+                       r0,   // actual number of arguments
+                       r2);  // expected number of arguments
+}
+
 // static
 constexpr auto ApiCallbackDescriptor::registers() {
   return RegisterArray(r1,   // kApiFunctionAddress
diff --git a/src/codegen/arm/macro-assembler-arm.cc b/src/codegen/arm/macro-assembler-arm.cc
index 26d16406a6..2f398f39ee 100644
--- a/src/codegen/arm/macro-assembler-arm.cc
+++ b/src/codegen/arm/macro-assembler-arm.cc
@@ -1595,6 +1595,53 @@ void TurboAssembler::MovFromFloatParameter(DwVfpRegister dst) {
   MovFromFloatResult(dst);
 }
 
+void TurboAssembler::PrepareForTailCall(Register callee_args_count,
+                                        Register caller_args_count,
+                                        Register scratch0, Register scratch1) {
+  DCHECK(!AreAliased(callee_args_count, caller_args_count, scratch0, scratch1));
+
+  // Calculate the end of destination area where we will put the arguments
+  // after we drop current frame. We add kPointerSize to count the receiver
+  // argument which is not included into formal parameters count.
+  Register dst_reg = scratch0;
+  add(dst_reg, fp, Operand(caller_args_count, LSL, kPointerSizeLog2));
+  add(dst_reg, dst_reg,
+      Operand(StandardFrameConstants::kCallerSPOffset + kPointerSize));
+
+  Register src_reg = caller_args_count;
+  // Calculate the end of source area. +kPointerSize is for the receiver.
+  add(src_reg, sp, Operand(callee_args_count, LSL, kPointerSizeLog2));
+  add(src_reg, src_reg, Operand(kPointerSize));
+
+  if (FLAG_debug_code) {
+    cmp(src_reg, dst_reg);
+    Check(lo, AbortReason::kStackAccessBelowStackPointer);
+  }
+
+  // Restore caller's frame pointer and return address now as they will be
+  // overwritten by the copying loop.
+  ldr(lr, MemOperand(fp, StandardFrameConstants::kCallerPCOffset));
+  ldr(fp, MemOperand(fp, StandardFrameConstants::kCallerFPOffset));
+
+  // Now copy callee arguments to the caller frame going backwards to avoid
+  // callee arguments corruption (source and destination areas could overlap).
+
+  // Both src_reg and dst_reg are pointing to the word after the one to copy,
+  // so they must be pre-decremented in the loop.
+  Register tmp_reg = scratch1;
+  Label loop, entry;
+  b(&entry);
+  bind(&loop);
+  ldr(tmp_reg, MemOperand(src_reg, -kPointerSize, PreIndex));
+  str(tmp_reg, MemOperand(dst_reg, -kPointerSize, PreIndex));
+  bind(&entry);
+  cmp(sp, src_reg);
+  b(ne, &loop);
+
+  // Leave current frame.
+  mov(sp, dst_reg);
+}
+
 void MacroAssembler::LoadStackLimit(Register destination, StackLimitKind kind) {
   ASM_CODE_COMMENT(this);
   DCHECK(root_array_available());
@@ -1637,58 +1684,15 @@ void MacroAssembler::InvokePrologue(Register expected_parameter_count,
   DCHECK_EQ(actual_parameter_count, r0);
   DCHECK_EQ(expected_parameter_count, r2);
 
-  // If the expected parameter count is equal to the adaptor sentinel, no need
-  // to push undefined value as arguments.
-  cmp(expected_parameter_count, Operand(kDontAdaptArgumentsSentinel));
+  cmp(expected_parameter_count, actual_parameter_count);
   b(eq, &regular_invoke);
 
-  // If overapplication or if the actual argument count is equal to the
-  // formal parameter count, no need to push extra undefined values.
-  sub(expected_parameter_count, expected_parameter_count,
-      actual_parameter_count, SetCC);
-  b(le, &regular_invoke);
-
-  Label stack_overflow;
-  Register scratch = r4;
-  StackOverflowCheck(expected_parameter_count, scratch, &stack_overflow);
-
-  // Underapplication. Move the arguments already in the stack, including the
-  // receiver and the return address.
-  {
-    Label copy, check;
-    Register num = r5, src = r6, dest = r9;  // r7 and r8 are context and root.
-    mov(src, sp);
-    // Update stack pointer.
-    lsl(scratch, expected_parameter_count, Operand(kSystemPointerSizeLog2));
-    AllocateStackSpace(scratch);
-    mov(dest, sp);
-    mov(num, actual_parameter_count);
-    b(&check);
-    bind(&copy);
-    ldr(scratch, MemOperand(src, kSystemPointerSize, PostIndex));
-    str(scratch, MemOperand(dest, kSystemPointerSize, PostIndex));
-    sub(num, num, Operand(1), SetCC);
-    bind(&check);
-    b(ge, &copy);
-  }
-
-  // Fill remaining expected arguments with undefined values.
-  LoadRoot(scratch, RootIndex::kUndefinedValue);
-  {
-    Label loop;
-    bind(&loop);
-    str(scratch, MemOperand(r9, kSystemPointerSize, PostIndex));
-    sub(expected_parameter_count, expected_parameter_count, Operand(1), SetCC);
-    b(gt, &loop);
-  }
-  b(&regular_invoke);
-
-  bind(&stack_overflow);
-  {
-    FrameScope frame(this,
-                     has_frame() ? StackFrame::NONE : StackFrame::INTERNAL);
-    CallRuntime(Runtime::kThrowStackOverflow);
-    bkpt(0);
+  Handle<Code> adaptor = BUILTIN_CODE(isolate(), ArgumentsAdaptorTrampoline);
+  if (type == InvokeType::kCall) {
+    Call(adaptor);
+    b(done);
+  } else {
+    Jump(adaptor, RelocInfo::CODE_TARGET);
   }
 
   bind(&regular_invoke);
diff --git a/src/codegen/arm/macro-assembler-arm.h b/src/codegen/arm/macro-assembler-arm.h
index 8baf5c48a8..9b355c1610 100644
--- a/src/codegen/arm/macro-assembler-arm.h
+++ b/src/codegen/arm/macro-assembler-arm.h
@@ -241,6 +241,10 @@ class V8_EXPORT_PRIVATE TurboAssembler : public TurboAssemblerBase {
   void PrepareCallCFunction(int num_reg_arguments, int num_double_registers = 0,
                             Register scratch = no_reg);
 
+  void PrepareForTailCall(Register callee_args_count,
+                          Register caller_args_count, Register scratch0,
+                          Register scratch1);
+
   // There are two ways of passing double arguments on ARM, depending on
   // whether soft or hard floating point ABI is used. These functions
   // abstract parameter passing for the three different ways we call
diff --git a/src/codegen/arm64/interface-descriptors-arm64-inl.h b/src/codegen/arm64/interface-descriptors-arm64-inl.h
index e8fe4ef1d3..cf113afc4b 100644
--- a/src/codegen/arm64/interface-descriptors-arm64-inl.h
+++ b/src/codegen/arm64/interface-descriptors-arm64-inl.h
@@ -232,6 +232,14 @@ constexpr auto BinaryOp_BaselineDescriptor::registers() {
   return RegisterArray(x1, x0, x2);
 }
 
+// static
+constexpr auto ArgumentsAdaptorDescriptor::registers() {
+  return RegisterArray(x1,   // JSFunction
+                       x3,   // the new target
+                       x0,   // actual number of arguments
+                       x2);  // expected number of arguments
+}
+
 // static
 constexpr auto ApiCallbackDescriptor::registers() {
   return RegisterArray(x1,   // kApiFunctionAddress
diff --git a/src/codegen/arm64/macro-assembler-arm64.cc b/src/codegen/arm64/macro-assembler-arm64.cc
index f125f2a932..ce12f11ad8 100644
--- a/src/codegen/arm64/macro-assembler-arm64.cc
+++ b/src/codegen/arm64/macro-assembler-arm64.cc
@@ -2215,6 +2215,61 @@ void TurboAssembler::CallForDeoptimization(
   }
 }
 
+void TurboAssembler::PrepareForTailCall(Register callee_args_count,
+                                        Register caller_args_count,
+                                        Register scratch0, Register scratch1) {
+  DCHECK(!AreAliased(callee_args_count, caller_args_count, scratch0, scratch1));
+
+  // Calculate the end of destination area where we will put the arguments
+  // after we drop current frame. We add kSystemPointerSize to count the
+  // receiver argument which is not included into formal parameters count.
+  Register dst_reg = scratch0;
+  Add(dst_reg, fp, Operand(caller_args_count, LSL, kSystemPointerSizeLog2));
+  Add(dst_reg, dst_reg,
+      StandardFrameConstants::kCallerSPOffset + kSystemPointerSize);
+  // Round dst_reg up to a multiple of 16 bytes, so that we overwrite any
+  // potential padding.
+  Add(dst_reg, dst_reg, 15);
+  Bic(dst_reg, dst_reg, 15);
+
+  Register src_reg = caller_args_count;
+  // Calculate the end of source area. +kSystemPointerSize is for the receiver.
+  Add(src_reg, sp, Operand(callee_args_count, LSL, kSystemPointerSizeLog2));
+  Add(src_reg, src_reg, kSystemPointerSize);
+
+  // Round src_reg up to a multiple of 16 bytes, so we include any potential
+  // padding in the copy.
+  Add(src_reg, src_reg, 15);
+  Bic(src_reg, src_reg, 15);
+
+  if (FLAG_debug_code) {
+    Cmp(src_reg, dst_reg);
+    Check(lo, AbortReason::kStackAccessBelowStackPointer);
+  }
+
+  // Restore caller's frame pointer and return address now as they will be
+  // overwritten by the copying loop.
+  RestoreFPAndLR();
+
+  // Now copy callee arguments to the caller frame going backwards to avoid
+  // callee arguments corruption (source and destination areas could overlap).
+
+  // Both src_reg and dst_reg are pointing to the word after the one to copy,
+  // so they must be pre-decremented in the loop.
+  Register tmp_reg = scratch1;
+  Label loop, entry;
+  B(&entry);
+  bind(&loop);
+  Ldr(tmp_reg, MemOperand(src_reg, -kSystemPointerSize, PreIndex));
+  Str(tmp_reg, MemOperand(dst_reg, -kSystemPointerSize, PreIndex));
+  bind(&entry);
+  Cmp(sp, src_reg);
+  B(ne, &loop);
+
+  // Leave current frame.
+  Mov(sp, dst_reg);
+}
+
 void MacroAssembler::LoadStackLimit(Register destination, StackLimitKind kind) {
   ASM_CODE_COMMENT(this);
   DCHECK(root_array_available());
@@ -2261,98 +2316,21 @@ void MacroAssembler::InvokePrologue(Register formal_parameter_count,
   DCHECK_EQ(actual_argument_count, x0);
   DCHECK_EQ(formal_parameter_count, x2);
 
-  // If the formal parameter count is equal to the adaptor sentinel, no need
-  // to push undefined value as arguments.
-  Cmp(formal_parameter_count, Operand(kDontAdaptArgumentsSentinel));
+  // Check whether the expected and actual arguments count match. The registers
+  // are set up according to contract with ArgumentsAdaptorTrampoline.ct.
+  // If actual == expected perform a regular invocation.
+  Cmp(formal_parameter_count, actual_argument_count);
   B(eq, &regular_invoke);
 
-  // If overapplication or if the actual argument count is equal to the
-  // formal parameter count, no need to push extra undefined values.
-  Register extra_argument_count = x2;
-  Subs(extra_argument_count, formal_parameter_count, actual_argument_count);
-  B(le, &regular_invoke);
-
-  // The stack pointer in arm64 needs to be 16-byte aligned. We might need to
-  // (1) add an extra padding or (2) remove (re-use) the extra padding already
-  // in the stack. Let {slots_to_copy} be the number of slots (arguments) to
-  // move up in the stack and let {slots_to_claim} be the number of extra stack
-  // slots to claim.
-  Label even_extra_count, skip_move;
-  Register slots_to_copy = x4;
-  Register slots_to_claim = x5;
-
-  Add(slots_to_copy, actual_argument_count, 1);  // Copy with receiver.
-  Mov(slots_to_claim, extra_argument_count);
-  Tbz(extra_argument_count, 0, &even_extra_count);
-
-  // Calculate {slots_to_claim} when {extra_argument_count} is odd.
-  // If {actual_argument_count} is even, we need one extra padding slot
-  // {slots_to_claim = extra_argument_count + 1}.
-  // If {actual_argument_count} is odd, we know that the
-  // original arguments will have a padding slot that we can reuse
-  // {slots_to_claim = extra_argument_count - 1}.
-  {
-    Register scratch = x11;
-    Add(slots_to_claim, extra_argument_count, 1);
-    And(scratch, actual_argument_count, 1);
-    Eor(scratch, scratch, 1);
-    Sub(slots_to_claim, slots_to_claim, Operand(scratch, LSL, 1));
-  }
-
-  Bind(&even_extra_count);
-  Cbz(slots_to_claim, &skip_move);
-
-  Label stack_overflow;
-  StackOverflowCheck(slots_to_claim, &stack_overflow);
-  Claim(slots_to_claim);
-
-  // Move the arguments already in the stack including the receiver.
-  {
-    Register src = x6;
-    Register dst = x7;
-    SlotAddress(src, slots_to_claim);
-    SlotAddress(dst, 0);
-    CopyDoubleWords(dst, src, slots_to_copy);
-  }
-
-  Bind(&skip_move);
-  Register actual_argument_with_receiver = x4;
-  Register pointer_next_value = x5;
-  Add(actual_argument_with_receiver, actual_argument_count,
-      1);  // {slots_to_copy} was scratched.
-
-  // Copy extra arguments as undefined values.
-  {
-    Label loop;
-    Register undefined_value = x6;
-    Register count = x7;
-    LoadRoot(undefined_value, RootIndex::kUndefinedValue);
-    SlotAddress(pointer_next_value, actual_argument_with_receiver);
-    Mov(count, extra_argument_count);
-    Bind(&loop);
-    Str(undefined_value,
-        MemOperand(pointer_next_value, kSystemPointerSize, PostIndex));
-    Subs(count, count, 1);
-    Cbnz(count, &loop);
-  }
-
-  // Set padding if needed.
-  {
-    Label skip;
-    Register total_args_slots = x4;
-    Add(total_args_slots, actual_argument_with_receiver, extra_argument_count);
-    Tbz(total_args_slots, 0, &skip);
-    Str(padreg, MemOperand(pointer_next_value));
-    Bind(&skip);
-  }
-  B(&regular_invoke);
-
-  bind(&stack_overflow);
-  {
-    FrameScope frame(this,
-                     has_frame() ? StackFrame::NONE : StackFrame::INTERNAL);
-    CallRuntime(Runtime::kThrowStackOverflow);
-    Unreachable();
+  // The argument counts mismatch, generate a call to the argument adaptor.
+  Handle<Code> adaptor = BUILTIN_CODE(isolate(), ArgumentsAdaptorTrampoline);
+  if (type == InvokeType::kCall) {
+    Call(adaptor);
+    // If the arg counts don't match, no extra code is emitted by
+    // MAsm::InvokeFunctionCode and we can just fall through.
+    B(done);
+  } else {
+    Jump(adaptor, RelocInfo::CODE_TARGET);
   }
 
   Bind(&regular_invoke);
diff --git a/src/codegen/arm64/macro-assembler-arm64.h b/src/codegen/arm64/macro-assembler-arm64.h
index 9128ba2c18..a761c4e4d2 100644
--- a/src/codegen/arm64/macro-assembler-arm64.h
+++ b/src/codegen/arm64/macro-assembler-arm64.h
@@ -555,6 +555,10 @@ class V8_EXPORT_PRIVATE TurboAssembler : public TurboAssemblerBase {
   inline void Isb();
   inline void Csdb();
 
+  void PrepareForTailCall(Register callee_args_count,
+                          Register caller_args_count, Register scratch0,
+                          Register scratch1);
+
   inline void SmiUntag(Register dst, Register src);
   inline void SmiUntag(Register dst, const MemOperand& src);
   inline void SmiUntag(Register smi);
diff --git a/src/codegen/code-factory.cc b/src/codegen/code-factory.cc
index f3cb604478..c0c7e09160 100644
--- a/src/codegen/code-factory.cc
+++ b/src/codegen/code-factory.cc
@@ -154,6 +154,11 @@ Callable CodeFactory::FastNewFunctionContext(Isolate* isolate,
   }
 }
 
+// static
+Callable CodeFactory::ArgumentAdaptor(Isolate* isolate) {
+  return Builtins::CallableFor(isolate, Builtin::kArgumentsAdaptorTrampoline);
+}
+
 // static
 Callable CodeFactory::Call(Isolate* isolate, ConvertReceiverMode mode) {
   return Callable(isolate->builtins()->Call(mode), CallTrampolineDescriptor{});
diff --git a/src/codegen/code-factory.h b/src/codegen/code-factory.h
index 4780678dad..93905147e8 100644
--- a/src/codegen/code-factory.h
+++ b/src/codegen/code-factory.h
@@ -56,6 +56,7 @@ class V8_EXPORT_PRIVATE CodeFactory final {
   static Callable FastNewFunctionContext(Isolate* isolate,
                                          ScopeType scope_type);
 
+  static Callable ArgumentAdaptor(Isolate* isolate);
   static Callable Call(Isolate* isolate,
                        ConvertReceiverMode mode = ConvertReceiverMode::kAny);
   static Callable Call_WithFeedback(Isolate* isolate, ConvertReceiverMode mode);
diff --git a/src/codegen/code-stub-assembler.h b/src/codegen/code-stub-assembler.h
index 008af6006f..4d3dd4c84f 100644
--- a/src/codegen/code-stub-assembler.h
+++ b/src/codegen/code-stub-assembler.h
@@ -305,6 +305,8 @@ enum class PrimitiveType { kBoolean, kNumber, kString, kSymbol };
 #define CSA_SLOW_ASSERT(csa, ...) ((void)0)
 #endif
 
+constexpr bool kNoArgumentsAdaptor = false;
+
 // Provides JavaScript-specific "macro-assembler" functionality on top of the
 // CodeAssembler. By factoring the JavaScript-isms out of the CodeAssembler,
 // it's possible to add JavaScript-specific useful CodeAssembler "macros"
diff --git a/src/codegen/ia32/interface-descriptors-ia32-inl.h b/src/codegen/ia32/interface-descriptors-ia32-inl.h
index b383b5df76..dd9cca214b 100644
--- a/src/codegen/ia32/interface-descriptors-ia32-inl.h
+++ b/src/codegen/ia32/interface-descriptors-ia32-inl.h
@@ -222,6 +222,14 @@ constexpr auto BinaryOp_BaselineDescriptor::registers() {
   return RegisterArray(edx, eax, ecx);
 }
 
+// static
+constexpr auto ArgumentsAdaptorDescriptor::registers() {
+  return RegisterArray(edi,   // JSFunction
+                       edx,   // the new target
+                       eax,   // actual number of arguments
+                       ecx);  // expected number of arguments
+}
+
 // static
 constexpr auto ApiCallbackDescriptor::registers() {
   return RegisterArray(edx,   // kApiFunctionAddress
diff --git a/src/codegen/ia32/macro-assembler-ia32.cc b/src/codegen/ia32/macro-assembler-ia32.cc
index f7e24ba896..2871cde59d 100644
--- a/src/codegen/ia32/macro-assembler-ia32.cc
+++ b/src/codegen/ia32/macro-assembler-ia32.cc
@@ -1503,6 +1503,59 @@ void MacroAssembler::JumpToInstructionStream(Address entry) {
   jmp(entry, RelocInfo::OFF_HEAP_TARGET);
 }
 
+void TurboAssembler::PrepareForTailCall(
+    Register callee_args_count, Register caller_args_count, Register scratch0,
+    Register scratch1, int number_of_temp_values_after_return_address) {
+  DCHECK(!AreAliased(callee_args_count, caller_args_count, scratch0, scratch1));
+
+  // Calculate the destination address where we will put the return address
+  // after we drop current frame.
+  Register new_sp_reg = scratch0;
+  sub(caller_args_count, callee_args_count);
+  lea(new_sp_reg, Operand(ebp, caller_args_count, times_system_pointer_size,
+                          StandardFrameConstants::kCallerPCOffset -
+                              number_of_temp_values_after_return_address *
+                                  kSystemPointerSize));
+
+  if (FLAG_debug_code) {
+    cmp(esp, new_sp_reg);
+    Check(below, AbortReason::kStackAccessBelowStackPointer);
+  }
+
+  // Copy return address from caller's frame to current frame's return address
+  // to avoid its trashing and let the following loop copy it to the right
+  // place.
+  Register tmp_reg = scratch1;
+  mov(tmp_reg, Operand(ebp, StandardFrameConstants::kCallerPCOffset));
+  mov(Operand(esp,
+              number_of_temp_values_after_return_address * kSystemPointerSize),
+      tmp_reg);
+
+  // Restore caller's frame pointer now as it could be overwritten by
+  // the copying loop.
+  mov(ebp, Operand(ebp, StandardFrameConstants::kCallerFPOffset));
+
+  // +2 here is to copy both receiver and return address.
+  Register count_reg = caller_args_count;
+  lea(count_reg, Operand(callee_args_count,
+                         2 + number_of_temp_values_after_return_address));
+
+  // Now copy callee arguments to the caller frame going backwards to avoid
+  // callee arguments corruption (source and destination areas could overlap).
+  Label loop, entry;
+  jmp(&entry, Label::kNear);
+  bind(&loop);
+  dec(count_reg);
+  mov(tmp_reg, Operand(esp, count_reg, times_system_pointer_size, 0));
+  mov(Operand(new_sp_reg, count_reg, times_system_pointer_size, 0), tmp_reg);
+  bind(&entry);
+  cmp(count_reg, Immediate(0));
+  j(not_equal, &loop, Label::kNear);
+
+  // Leave current frame.
+  mov(esp, new_sp_reg);
+}
+
 void MacroAssembler::CompareStackLimit(Register with, StackLimitKind kind) {
   ASM_CODE_COMMENT(this);
   DCHECK(root_array_available());
@@ -1555,79 +1608,17 @@ void MacroAssembler::InvokePrologue(Register expected_parameter_count,
   DCHECK_EQ(expected_parameter_count, ecx);
   Label regular_invoke;
 
-  // If the expected parameter count is equal to the adaptor sentinel, no need
-  // to push undefined value as arguments.
-  cmp(expected_parameter_count, Immediate(kDontAdaptArgumentsSentinel));
-  j(equal, &regular_invoke, Label::kFar);
-
-  // If overapplication or if the actual argument count is equal to the
-  // formal parameter count, no need to push extra undefined values.
-  sub(expected_parameter_count, actual_parameter_count);
-  j(less_equal, &regular_invoke, Label::kFar);
-
-  // We need to preserve edx, edi, esi and ebx.
-  movd(xmm0, edx);
-  movd(xmm1, edi);
-  movd(xmm2, esi);
-  movd(xmm3, ebx);
-
-  Label stack_overflow;
-  StackOverflowCheck(expected_parameter_count, edx, &stack_overflow);
-
-  Register scratch = esi;
-
-  // Underapplication. Move the arguments already in the stack, including the
-  // receiver and the return address.
-  {
-    Label copy, check;
-    Register src = edx, dest = esp, num = edi, current = ebx;
-    mov(src, esp);
-    lea(scratch,
-        Operand(expected_parameter_count, times_system_pointer_size, 0));
-    AllocateStackSpace(scratch);
-    // Extra words are the receiver and the return address (if a jump).
-    int extra_words = type == InvokeType::kCall ? 1 : 2;
-    lea(num, Operand(eax, extra_words));  // Number of words to copy.
-    Move(current, 0);
-    // Fall-through to the loop body because there are non-zero words to copy.
-    bind(&copy);
-    mov(scratch, Operand(src, current, times_system_pointer_size, 0));
-    mov(Operand(dest, current, times_system_pointer_size, 0), scratch);
-    inc(current);
-    bind(&check);
-    cmp(current, num);
-    j(less, &copy);
-    lea(edx, Operand(esp, num, times_system_pointer_size, 0));
-  }
-
-    // Fill remaining expected arguments with undefined values.
-    movd(ebx, xmm3);  // Restore root.
-    LoadRoot(scratch, RootIndex::kUndefinedValue);
-    {
-      Label loop;
-      bind(&loop);
-      dec(expected_parameter_count);
-      mov(Operand(edx, expected_parameter_count, times_system_pointer_size, 0),
-          scratch);
-      j(greater, &loop, Label::kNear);
-    }
-
-    // Restore remaining registers.
-    movd(esi, xmm2);
-    movd(edi, xmm1);
-    movd(edx, xmm0);
-
-    jmp(&regular_invoke);
-
-    bind(&stack_overflow);
-    {
-      FrameScope frame(this,
-                       has_frame() ? StackFrame::NONE : StackFrame::INTERNAL);
-      CallRuntime(Runtime::kThrowStackOverflow);
-      int3();  // This should be unreachable.
-    }
+  cmp(expected_parameter_count, actual_parameter_count);
+  j(equal, &regular_invoke);
+  Handle<Code> adaptor = BUILTIN_CODE(isolate(), ArgumentsAdaptorTrampoline);
+  if (type == InvokeType::kCall) {
+    Call(adaptor, RelocInfo::CODE_TARGET);
+    jmp(done, Label::kNear);
+  } else {
+    Jump(adaptor, RelocInfo::CODE_TARGET);
+  }
 
-    bind(&regular_invoke);
+  bind(&regular_invoke);
 }
 
 void MacroAssembler::CallDebugOnFunctionCall(Register fun, Register new_target,
diff --git a/src/codegen/ia32/macro-assembler-ia32.h b/src/codegen/ia32/macro-assembler-ia32.h
index 527c357047..371a9acaae 100644
--- a/src/codegen/ia32/macro-assembler-ia32.h
+++ b/src/codegen/ia32/macro-assembler-ia32.h
@@ -203,6 +203,11 @@ class V8_EXPORT_PRIVATE TurboAssembler : public SharedTurboAssembler {
     SmiUntag(output);
   }
 
+  void PrepareForTailCall(Register callee_args_count,
+                          Register caller_args_count, Register scratch0,
+                          Register scratch1,
+                          int number_of_temp_values_after_return_address);
+
   // Before calling a C-function from generated code, align arguments on stack.
   // After aligning the frame, arguments must be stored in esp[0], esp[4],
   // etc., not pushed. The argument count assumes all arguments are word sized.
diff --git a/src/codegen/interface-descriptors.h b/src/codegen/interface-descriptors.h
index 10deb0ad41..994f000cf5 100644
--- a/src/codegen/interface-descriptors.h
+++ b/src/codegen/interface-descriptors.h
@@ -26,6 +26,7 @@ namespace internal {
   V(Allocate)                            \
   V(ApiCallback)                         \
   V(ApiGetter)                           \
+  V(ArgumentsAdaptor)                    \
   V(ArrayConstructor)                    \
   V(ArrayNArgumentsConstructor)          \
   V(ArrayNoArgumentConstructor)          \
@@ -1506,6 +1507,16 @@ class StringSubstringDescriptor final
   DECLARE_DESCRIPTOR(StringSubstringDescriptor)
 };
 
+class ArgumentsAdaptorDescriptor
+    : public StaticCallInterfaceDescriptor<ArgumentsAdaptorDescriptor> {
+ public:
+  DEFINE_JS_PARAMETERS(kExpectedArgumentsCount)
+  DEFINE_JS_PARAMETER_TYPES(MachineType::Int32())
+  DECLARE_DESCRIPTOR(ArgumentsAdaptorDescriptor)
+
+  static constexpr inline auto registers();
+};
+
 class CppBuiltinAdaptorDescriptor
     : public StaticJSCallInterfaceDescriptor<CppBuiltinAdaptorDescriptor> {
  public:
diff --git a/src/codegen/x64/interface-descriptors-x64-inl.h b/src/codegen/x64/interface-descriptors-x64-inl.h
index 50ba12b836..b126e587cd 100644
--- a/src/codegen/x64/interface-descriptors-x64-inl.h
+++ b/src/codegen/x64/interface-descriptors-x64-inl.h
@@ -247,6 +247,14 @@ constexpr auto BinaryOp_BaselineDescriptor::registers() {
   return RegisterArray(rdx, rax, rbx);
 }
 
+// static
+constexpr auto ArgumentsAdaptorDescriptor::registers() {
+  return RegisterArray(rdi,   // JSFunction
+                       rdx,   // the new target
+                       rax,   // actual number of arguments
+                       rbx);  // expected number of arguments
+}
+
 // static
 constexpr auto ApiCallbackDescriptor::registers() {
   return RegisterArray(rdx,   // api function address
diff --git a/src/codegen/x64/macro-assembler-x64.cc b/src/codegen/x64/macro-assembler-x64.cc
index c064f671e3..8a699e6d10 100644
--- a/src/codegen/x64/macro-assembler-x64.cc
+++ b/src/codegen/x64/macro-assembler-x64.cc
@@ -2923,6 +2923,54 @@ void MacroAssembler::EmitDecrementCounter(StatsCounter* counter, int value) {
   }
 }
 
+void TurboAssembler::PrepareForTailCall(Register callee_args_count,
+                                        Register caller_args_count,
+                                        Register scratch0, Register scratch1) {
+  DCHECK(!AreAliased(callee_args_count, caller_args_count, scratch0, scratch1));
+
+  // Calculate the destination address where we will put the return address
+  // after we drop current frame.
+  Register new_sp_reg = scratch0;
+  subq(caller_args_count, callee_args_count);
+  leaq(new_sp_reg, Operand(rbp, caller_args_count, times_system_pointer_size,
+                           StandardFrameConstants::kCallerPCOffset));
+
+  if (FLAG_debug_code) {
+    cmpq(rsp, new_sp_reg);
+    Check(below, AbortReason::kStackAccessBelowStackPointer);
+  }
+
+  // Copy return address from caller's frame to current frame's return address
+  // to avoid its trashing and let the following loop copy it to the right
+  // place.
+  Register tmp_reg = scratch1;
+  movq(tmp_reg, Operand(rbp, StandardFrameConstants::kCallerPCOffset));
+  movq(Operand(rsp, 0), tmp_reg);
+
+  // Restore caller's frame pointer now as it could be overwritten by
+  // the copying loop.
+  movq(rbp, Operand(rbp, StandardFrameConstants::kCallerFPOffset));
+
+  // +2 here is to copy both receiver and return address.
+  Register count_reg = caller_args_count;
+  leaq(count_reg, Operand(callee_args_count, 2));
+
+  // Now copy callee arguments to the caller frame going backwards to avoid
+  // callee arguments corruption (source and destination areas could overlap).
+  Label loop, entry;
+  jmp(&entry, Label::kNear);
+  bind(&loop);
+  decq(count_reg);
+  movq(tmp_reg, Operand(rsp, count_reg, times_system_pointer_size, 0));
+  movq(Operand(new_sp_reg, count_reg, times_system_pointer_size, 0), tmp_reg);
+  bind(&entry);
+  cmpq(count_reg, Immediate(0));
+  j(not_equal, &loop, Label::kNear);
+
+  // Leave current frame.
+  movq(rsp, new_sp_reg);
+}
+
 void MacroAssembler::InvokeFunction(Register function, Register new_target,
                                     Register actual_parameter_count,
                                     InvokeType type) {
@@ -3046,63 +3094,21 @@ void MacroAssembler::InvokePrologue(Register expected_parameter_count,
       return;
     }
     Label regular_invoke;
-    // If the expected parameter count is equal to the adaptor sentinel, no need
-    // to push undefined value as arguments.
-    cmpl(expected_parameter_count, Immediate(kDontAdaptArgumentsSentinel));
-    j(equal, &regular_invoke, Label::kFar);
-
-    // If overapplication or if the actual argument count is equal to the
-    // formal parameter count, no need to push extra undefined values.
-    subq(expected_parameter_count, actual_parameter_count);
-    j(less_equal, &regular_invoke, Label::kFar);
-
-    Label stack_overflow;
-    StackOverflowCheck(expected_parameter_count, &stack_overflow);
-
-    // Underapplication. Move the arguments already in the stack, including the
-    // receiver and the return address.
-    {
-      Label copy, check;
-      Register src = r8, dest = rsp, num = r9, current = r11;
-      movq(src, rsp);
-      leaq(kScratchRegister,
-           Operand(expected_parameter_count, times_system_pointer_size, 0));
-      AllocateStackSpace(kScratchRegister);
-      // Extra words are the receiver and the return address (if a jump).
-      int extra_words = type == InvokeType::kCall ? 1 : 2;
-      leaq(num, Operand(rax, extra_words));  // Number of words to copy.
-      Move(current, 0);
-      // Fall-through to the loop body because there are non-zero words to copy.
-      bind(&copy);
-      movq(kScratchRegister,
-           Operand(src, current, times_system_pointer_size, 0));
-      movq(Operand(dest, current, times_system_pointer_size, 0),
-           kScratchRegister);
-      incq(current);
-      bind(&check);
-      cmpq(current, num);
-      j(less, &copy);
-      leaq(r8, Operand(rsp, num, times_system_pointer_size, 0));
-    }
-    // Fill remaining expected arguments with undefined values.
-    LoadRoot(kScratchRegister, RootIndex::kUndefinedValue);
-    {
-      Label loop;
-      bind(&loop);
-      decq(expected_parameter_count);
-      movq(Operand(r8, expected_parameter_count, times_system_pointer_size, 0),
-           kScratchRegister);
-      j(greater, &loop, Label::kNear);
-    }
-    jmp(&regular_invoke);
-
-    bind(&stack_overflow);
-    {
-      FrameScope frame(this,
-                       has_frame() ? StackFrame::NONE : StackFrame::INTERNAL);
-      CallRuntime(Runtime::kThrowStackOverflow);
-      int3();  // This should be unreachable.
+
+    // Both expected and actual are in (different) registers. This
+    // is the case when we invoke functions using call and apply.
+    cmpq(expected_parameter_count, actual_parameter_count);
+    j(equal, &regular_invoke, Label::kNear);
+    DCHECK_EQ(actual_parameter_count, rax);
+    DCHECK_EQ(expected_parameter_count, rbx);
+    Handle<Code> adaptor = BUILTIN_CODE(isolate(), ArgumentsAdaptorTrampoline);
+    if (type == InvokeType::kCall) {
+      Call(adaptor, RelocInfo::CODE_TARGET);
+      jmp(done, Label::kNear);
+    } else {
+      Jump(adaptor, RelocInfo::CODE_TARGET);
     }
+
     bind(&regular_invoke);
 }
 
diff --git a/src/codegen/x64/macro-assembler-x64.h b/src/codegen/x64/macro-assembler-x64.h
index 02b9eb410e..76f874f36d 100644
--- a/src/codegen/x64/macro-assembler-x64.h
+++ b/src/codegen/x64/macro-assembler-x64.h
@@ -570,6 +570,10 @@ class V8_EXPORT_PRIVATE TurboAssembler : public SharedTurboAssembler {
   }
 #endif
 
+  void PrepareForTailCall(Register callee_args_count,
+                          Register caller_args_count, Register scratch0,
+                          Register scratch1);
+
   void InitializeRootRegister() {
     ExternalReference isolate_root = ExternalReference::isolate_root(isolate());
     Move(kRootRegister, isolate_root);
diff --git a/src/compiler/backend/arm/code-generator-arm.cc b/src/compiler/backend/arm/code-generator-arm.cc
index 29c7897ec9..dea0dd334b 100644
--- a/src/compiler/backend/arm/code-generator-arm.cc
+++ b/src/compiler/backend/arm/code-generator-arm.cc
@@ -551,6 +551,30 @@ void CodeGenerator::AssemblePrepareTailCall() {
   frame_access_state()->SetFrameAccessToSP();
 }
 
+void CodeGenerator::AssemblePopArgumentsAdaptorFrame(Register args_reg,
+                                                     Register scratch1,
+                                                     Register scratch2,
+                                                     Register scratch3) {
+  DCHECK(!AreAliased(args_reg, scratch1, scratch2, scratch3));
+  Label done;
+
+  // Check if current frame is an arguments adaptor frame.
+  __ ldr(scratch1, MemOperand(fp, StandardFrameConstants::kContextOffset));
+  __ cmp(scratch1,
+         Operand(StackFrame::TypeToMarker(StackFrame::ARGUMENTS_ADAPTOR)));
+  __ b(ne, &done);
+
+  // Load arguments count from current arguments adaptor frame (note, it
+  // does not include receiver).
+  Register caller_args_count_reg = scratch1;
+  __ ldr(caller_args_count_reg,
+         MemOperand(fp, ArgumentsAdaptorFrameConstants::kLengthOffset));
+  __ SmiUntag(caller_args_count_reg);
+
+  __ PrepareForTailCall(args_reg, caller_args_count_reg, scratch2, scratch3);
+  __ bind(&done);
+}
+
 namespace {
 
 void FlushPendingPushRegisters(TurboAssembler* tasm,
@@ -771,7 +795,13 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(
       break;
     }
 #endif  // V8_ENABLE_WEBASSEMBLY
+    case kArchTailCallCodeObjectFromJSFunction:
     case kArchTailCallCodeObject: {
+      if (arch_opcode == kArchTailCallCodeObjectFromJSFunction) {
+        AssemblePopArgumentsAdaptorFrame(kJavaScriptCallArgCountRegister,
+                                         i.TempRegister(0), i.TempRegister(1),
+                                         i.TempRegister(2));
+      }
       if (instr->InputAt(0)->IsImmediate()) {
         __ Jump(i.InputCode(0), RelocInfo::CODE_TARGET);
       } else {
@@ -3919,13 +3949,7 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
   }
 
   Register argc_reg = r3;
-  // Functions with JS linkage have at least one parameter (the receiver).
-  // If {parameter_slots} == 0, it means it is a builtin with
-  // kDontAdaptArgumentsSentinel, which takes care of JS arguments popping
-  // itself.
-  const bool drop_jsargs = parameter_slots != 0 &&
-                           frame_access_state()->has_frame() &&
-                           call_descriptor->IsJSFunctionCall();
+  const bool drop_jsargs = false;
   if (call_descriptor->IsCFunctionCall()) {
     AssembleDeconstructFrame();
   } else if (frame_access_state()->has_frame()) {
diff --git a/src/compiler/backend/arm/instruction-selector-arm.cc b/src/compiler/backend/arm/instruction-selector-arm.cc
index 2698d45ae7..c0758aadc2 100644
--- a/src/compiler/backend/arm/instruction-selector-arm.cc
+++ b/src/compiler/backend/arm/instruction-selector-arm.cc
@@ -1740,6 +1740,8 @@ void InstructionSelector::EmitPrepareResults(
 
 bool InstructionSelector::IsTailCallAddressImmediate() { return false; }
 
+int InstructionSelector::GetTempsCountForTailCallFromJSFunction() { return 3; }
+
 namespace {
 
 // Shared routine for multiple compare operations.
diff --git a/src/compiler/backend/arm64/code-generator-arm64.cc b/src/compiler/backend/arm64/code-generator-arm64.cc
index c121383426..1e0800add0 100644
--- a/src/compiler/backend/arm64/code-generator-arm64.cc
+++ b/src/compiler/backend/arm64/code-generator-arm64.cc
@@ -643,6 +643,30 @@ void CodeGenerator::AssemblePrepareTailCall() {
   frame_access_state()->SetFrameAccessToSP();
 }
 
+void CodeGenerator::AssemblePopArgumentsAdaptorFrame(Register args_reg,
+                                                     Register scratch1,
+                                                     Register scratch2,
+                                                     Register scratch3) {
+  DCHECK(!AreAliased(args_reg, scratch1, scratch2, scratch3));
+  Label done;
+
+  // Check if current frame is an arguments adaptor frame.
+  __ Ldr(scratch1, MemOperand(fp, StandardFrameConstants::kContextOffset));
+  __ Cmp(scratch1,
+         Operand(StackFrame::TypeToMarker(StackFrame::ARGUMENTS_ADAPTOR)));
+  __ B(ne, &done);
+
+  // Load arguments count from current arguments adaptor frame (note, it
+  // does not include receiver).
+  Register caller_args_count_reg = scratch1;
+  __ Ldr(caller_args_count_reg,
+         MemOperand(fp, ArgumentsAdaptorFrameConstants::kLengthOffset));
+  __ SmiUntag(caller_args_count_reg);
+
+  __ PrepareForTailCall(args_reg, caller_args_count_reg, scratch2, scratch3);
+  __ bind(&done);
+}
+
 namespace {
 
 void AdjustStackPointerForTailCall(TurboAssembler* tasm,
@@ -798,7 +822,13 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(
       break;
     }
 #endif  // V8_ENABLE_WEBASSEMBLY
+    case kArchTailCallCodeObjectFromJSFunction:
     case kArchTailCallCodeObject: {
+      if (arch_opcode == kArchTailCallCodeObjectFromJSFunction) {
+        AssemblePopArgumentsAdaptorFrame(kJavaScriptCallArgCountRegister,
+                                         i.TempRegister(0), i.TempRegister(1),
+                                         i.TempRegister(2));
+      }
       if (instr->InputAt(0)->IsImmediate()) {
         __ Jump(i.InputCode(0), RelocInfo::CODE_TARGET);
       } else {
@@ -3309,13 +3339,7 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
   }
 
   Register argc_reg = x3;
-  // Functions with JS linkage have at least one parameter (the receiver).
-  // If {parameter_slots} == 0, it means it is a builtin with
-  // kDontAdaptArgumentsSentinel, which takes care of JS arguments popping
-  // itself.
-  const bool drop_jsargs = parameter_slots != 0 &&
-                           frame_access_state()->has_frame() &&
-                           call_descriptor->IsJSFunctionCall();
+  const bool drop_jsargs = false;
   if (call_descriptor->IsCFunctionCall()) {
     AssembleDeconstructFrame();
   } else if (frame_access_state()->has_frame()) {
diff --git a/src/compiler/backend/arm64/instruction-selector-arm64.cc b/src/compiler/backend/arm64/instruction-selector-arm64.cc
index 6a1a101e35..b1ae4a5982 100644
--- a/src/compiler/backend/arm64/instruction-selector-arm64.cc
+++ b/src/compiler/backend/arm64/instruction-selector-arm64.cc
@@ -2146,6 +2146,8 @@ void InstructionSelector::EmitPrepareResults(
 
 bool InstructionSelector::IsTailCallAddressImmediate() { return false; }
 
+int InstructionSelector::GetTempsCountForTailCallFromJSFunction() { return 3; }
+
 namespace {
 
 // Shared routine for multiple compare operations.
diff --git a/src/compiler/backend/code-generator.h b/src/compiler/backend/code-generator.h
index 7ccb09d5ac..e16962734d 100644
--- a/src/compiler/backend/code-generator.h
+++ b/src/compiler/backend/code-generator.h
@@ -301,6 +301,10 @@ class V8_EXPORT_PRIVATE CodeGenerator final : public GapResolver::Assembler {
   // Generates code to manipulate the stack in preparation for a tail call.
   void AssemblePrepareTailCall();
 
+  // Generates code to pop current frame if it is an arguments adaptor frame.
+  void AssemblePopArgumentsAdaptorFrame(Register args_reg, Register scratch1,
+                                        Register scratch2, Register scratch3);
+
   enum PushTypeFlag {
     kImmediatePush = 0x1,
     kRegisterPush = 0x2,
diff --git a/src/compiler/backend/ia32/code-generator-ia32.cc b/src/compiler/backend/ia32/code-generator-ia32.cc
index 5db3f20fa4..a1cc7e3e1c 100644
--- a/src/compiler/backend/ia32/code-generator-ia32.cc
+++ b/src/compiler/backend/ia32/code-generator-ia32.cc
@@ -572,6 +572,43 @@ void CodeGenerator::AssemblePrepareTailCall() {
   frame_access_state()->SetFrameAccessToSP();
 }
 
+void CodeGenerator::AssemblePopArgumentsAdaptorFrame(Register args_reg,
+                                                     Register, Register,
+                                                     Register) {
+  // There are not enough temp registers left on ia32 for a call instruction
+  // so we pick some scratch registers and save/restore them manually here.
+  int scratch_count = 3;
+  Register scratch1 = esi;
+  Register scratch2 = ecx;
+  Register scratch3 = edx;
+  DCHECK(!AreAliased(args_reg, scratch1, scratch2, scratch3));
+  Label done;
+
+  // Check if current frame is an arguments adaptor frame.
+  __ cmp(Operand(ebp, StandardFrameConstants::kContextOffset),
+         Immediate(StackFrame::TypeToMarker(StackFrame::ARGUMENTS_ADAPTOR)));
+  __ j(not_equal, &done, Label::kNear);
+
+  __ push(scratch1);
+  __ push(scratch2);
+  __ push(scratch3);
+
+  // Load arguments count from current arguments adaptor frame (note, it
+  // does not include receiver).
+  Register caller_args_count_reg = scratch1;
+  __ mov(caller_args_count_reg,
+         Operand(ebp, ArgumentsAdaptorFrameConstants::kLengthOffset));
+  __ SmiUntag(caller_args_count_reg);
+
+  __ PrepareForTailCall(args_reg, caller_args_count_reg, scratch2, scratch3,
+                        scratch_count);
+  __ pop(scratch3);
+  __ pop(scratch2);
+  __ pop(scratch1);
+
+  __ bind(&done);
+}
+
 namespace {
 
 void AdjustStackPointerForTailCall(TurboAssembler* tasm,
@@ -774,7 +811,12 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(
       break;
     }
 #endif  // V8_ENABLE_WEBASSEMBLY
+    case kArchTailCallCodeObjectFromJSFunction:
     case kArchTailCallCodeObject: {
+      if (arch_opcode == kArchTailCallCodeObjectFromJSFunction) {
+        AssemblePopArgumentsAdaptorFrame(kJavaScriptCallArgCountRegister,
+                                         no_reg, no_reg, no_reg);
+      }
       if (HasImmediateInput(instr, 0)) {
         Handle<Code> code = i.InputCode(0);
         __ Jump(code, RelocInfo::CODE_TARGET);
@@ -4613,14 +4655,7 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
   }
 
   Register argc_reg = ecx;
-  // Functions with JS linkage have at least one parameter (the receiver).
-  // If {parameter_slots} == 0, it means it is a builtin with
-  // kDontAdaptArgumentsSentinel, which takes care of JS arguments popping
-  // itself.
-
-  const bool drop_jsargs = parameter_slots != 0 &&
-                           frame_access_state()->has_frame() &&
-                           call_descriptor->IsJSFunctionCall();
+  const bool drop_jsargs = false;
   if (call_descriptor->IsCFunctionCall()) {
     AssembleDeconstructFrame();
   } else if (frame_access_state()->has_frame()) {
diff --git a/src/compiler/backend/ia32/instruction-selector-ia32.cc b/src/compiler/backend/ia32/instruction-selector-ia32.cc
index f36fdb2935..0d83a0a386 100644
--- a/src/compiler/backend/ia32/instruction-selector-ia32.cc
+++ b/src/compiler/backend/ia32/instruction-selector-ia32.cc
@@ -1430,6 +1430,8 @@ void InstructionSelector::EmitPrepareResults(
 
 bool InstructionSelector::IsTailCallAddressImmediate() { return true; }
 
+int InstructionSelector::GetTempsCountForTailCallFromJSFunction() { return 0; }
+
 namespace {
 
 void VisitCompareWithMemoryOperand(InstructionSelector* selector,
diff --git a/src/compiler/backend/instruction-codes.h b/src/compiler/backend/instruction-codes.h
index 31d669813e..87c1c766ba 100644
--- a/src/compiler/backend/instruction-codes.h
+++ b/src/compiler/backend/instruction-codes.h
@@ -69,6 +69,7 @@ inline RecordWriteMode WriteBarrierKindToRecordWriteMode(
   /* Tail call opcodes are grouped together to make IsTailCall fast */     \
   /* and Arch call opcodes are grouped together to make */                 \
   /* IsCallWithDescriptorFlags fast */                                     \
+  V(ArchTailCallCodeObjectFromJSFunction)                                  \
   V(ArchTailCallCodeObject)                                                \
   V(ArchTailCallAddress)                                                   \
   IF_WASM(V, ArchTailCallWasm)                                             \
diff --git a/src/compiler/backend/instruction-scheduler.cc b/src/compiler/backend/instruction-scheduler.cc
index c46d263bae..bc06608090 100644
--- a/src/compiler/backend/instruction-scheduler.cc
+++ b/src/compiler/backend/instruction-scheduler.cc
@@ -305,6 +305,7 @@ int InstructionScheduler::GetInstructionFlags(const Instruction* instr) const {
 
     case kArchPrepareCallCFunction:
     case kArchPrepareTailCall:
+    case kArchTailCallCodeObjectFromJSFunction:
     case kArchTailCallCodeObject:
     case kArchTailCallAddress:
 #if V8_ENABLE_WEBASSEMBLY
diff --git a/src/compiler/backend/instruction-selector.cc b/src/compiler/backend/instruction-selector.cc
index f279ea1590..3faa9b2fdc 100644
--- a/src/compiler/backend/instruction-selector.cc
+++ b/src/compiler/backend/instruction-selector.cc
@@ -2927,6 +2927,7 @@ void InstructionSelector::UpdateMaxPushedArgumentCount(size_t count) {
 void InstructionSelector::VisitCall(Node* node, BasicBlock* handler) {
   OperandGenerator g(this);
   auto call_descriptor = CallDescriptorOf(node->op());
+  auto caller = linkage()->GetIncomingDescriptor();
   SaveFPRegsMode mode = call_descriptor->NeedsCallerSavedFPRegisters()
                             ? SaveFPRegsMode::kSave
                             : SaveFPRegsMode::kIgnore;
@@ -2965,6 +2966,7 @@ void InstructionSelector::VisitCall(Node* node, BasicBlock* handler) {
 
   // Select the appropriate opcode based on the call type.
   InstructionCode opcode;
+  InstructionOperandVector temps(zone());
   switch (call_descriptor->kind()) {
     case CallDescriptor::kCallAddress: {
       int misc_field = static_cast<int>(call_descriptor->ParameterCount());
@@ -2982,9 +2984,18 @@ void InstructionSelector::VisitCall(Node* node, BasicBlock* handler) {
     case CallDescriptor::kCallCodeObject:
       opcode = EncodeCallDescriptorFlags(kArchCallCodeObject, flags);
       break;
-    case CallDescriptor::kCallJSFunction:
-      opcode = EncodeCallDescriptorFlags(kArchCallJSFunction, flags);
+    case CallDescriptor::kCallJSFunction: {
+      if (caller->IsJSFunctionCall()) {
+        opcode = EncodeCallDescriptorFlags(kArchTailCallCodeObjectFromJSFunction, flags);
+        int temps_count = GetTempsCountForTailCallFromJSFunction();
+        for (int i = 0; i < temps_count; i++) {
+          temps.push_back(g.TempRegister());
+        }
+      } else {
+        opcode = EncodeCallDescriptorFlags(kArchCallJSFunction, flags);
+      }
       break;
+    }
 #if V8_ENABLE_WEBASSEMBLY
     case CallDescriptor::kCallWasmCapiFunction:
     case CallDescriptor::kCallWasmFunction:
diff --git a/src/compiler/backend/instruction-selector.h b/src/compiler/backend/instruction-selector.h
index 11a329d1d6..45460183a0 100644
--- a/src/compiler/backend/instruction-selector.h
+++ b/src/compiler/backend/instruction-selector.h
@@ -601,6 +601,7 @@ class V8_EXPORT_PRIVATE InstructionSelector final {
   void InitializeCallBuffer(Node* call, CallBuffer* buffer,
                             CallBufferFlags flags, int stack_slot_delta = 0);
   bool IsTailCallAddressImmediate();
+  int GetTempsCountForTailCallFromJSFunction();
 
   void UpdateMaxPushedArgumentCount(size_t count);
 
diff --git a/src/compiler/backend/instruction.cc b/src/compiler/backend/instruction.cc
index 63ca78e060..c50c13cf02 100644
--- a/src/compiler/backend/instruction.cc
+++ b/src/compiler/backend/instruction.cc
@@ -1025,14 +1025,11 @@ size_t GetConservativeFrameSizeInBytes(FrameStateType type,
           static_cast<int>(parameters_count), static_cast<int>(locals_count));
       return info.frame_size_in_bytes();
     }
-    case FrameStateType::kArgumentsAdaptor:
-      // The arguments adaptor frame state is only used in the deoptimizer and
-      // does not occupy any extra space in the stack. Check out the design doc:
-      // https://docs.google.com/document/d/150wGaUREaZI6YWqOQFD5l2mWQXaPbbZjcAIJLOFrzMs/edit
-      // We just need to account for the additional parameters we might push
-      // here.
-      return UnoptimizedFrameInfo::GetStackSizeForAdditionalArguments(
+    case FrameStateType::kArgumentsAdaptor: {
+      auto info = ArgumentsAdaptorFrameInfo::Conservative(
           static_cast<int>(parameters_count));
+      return info.frame_size_in_bytes();
+    }
     case FrameStateType::kConstructStub: {
       auto info = ConstructStubFrameInfo::Conservative(
           static_cast<int>(parameters_count));
diff --git a/src/compiler/backend/x64/code-generator-x64.cc b/src/compiler/backend/x64/code-generator-x64.cc
index 60a40fb489..8f0cec5b0c 100644
--- a/src/compiler/backend/x64/code-generator-x64.cc
+++ b/src/compiler/backend/x64/code-generator-x64.cc
@@ -904,6 +904,28 @@ void CodeGenerator::AssemblePrepareTailCall() {
   frame_access_state()->SetFrameAccessToSP();
 }
 
+void CodeGenerator::AssemblePopArgumentsAdaptorFrame(Register args_reg,
+                                                     Register scratch1,
+                                                     Register scratch2,
+                                                     Register scratch3) {
+  DCHECK(!AreAliased(args_reg, scratch1, scratch2, scratch3));
+  Label done;
+
+  // Check if current frame is an arguments adaptor frame.
+  __ cmpq(Operand(rbp, CommonFrameConstants::kContextOrFrameTypeOffset),
+          Immediate(StackFrame::TypeToMarker(StackFrame::ARGUMENTS_ADAPTOR)));
+  __ j(not_equal, &done, Label::kNear);
+
+  // Load arguments count from current arguments adaptor frame (note, it
+  // does not include receiver).
+  Register caller_args_count_reg = scratch1;
+  __ SmiUntag(caller_args_count_reg,
+              Operand(rbp, ArgumentsAdaptorFrameConstants::kLengthOffset));
+
+  __ PrepareForTailCall(args_reg, caller_args_count_reg, scratch2, scratch3);
+  __ bind(&done);
+}
+
 namespace {
 
 void AdjustStackPointerForTailCall(Instruction* instr,
@@ -1120,6 +1142,13 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(
       break;
     }
 #endif  // V8_ENABLE_WEBASSEMBLY
+    case kArchTailCallCodeObjectFromJSFunction:
+      if (!instr->HasCallDescriptorFlag(CallDescriptor::kIsTailCallForTierUp)) {
+        AssemblePopArgumentsAdaptorFrame(kJavaScriptCallArgCountRegister,
+                                         i.TempRegister(0), i.TempRegister(1),
+                                         i.TempRegister(2));
+      }
+      V8_FALLTHROUGH;
     case kArchTailCallCodeObject: {
       if (HasImmediateInput(instr, 0)) {
         Handle<Code> code = i.InputCode(0);
@@ -4843,13 +4872,7 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
   }
 
   Register argc_reg = rcx;
-  // Functions with JS linkage have at least one parameter (the receiver).
-  // If {parameter_slots} == 0, it means it is a builtin with
-  // kDontAdaptArgumentsSentinel, which takes care of JS arguments popping
-  // itself.
-  const bool drop_jsargs = parameter_slots != 0 &&
-                           frame_access_state()->has_frame() &&
-                           call_descriptor->IsJSFunctionCall();
+  const bool drop_jsargs = false;
   if (call_descriptor->IsCFunctionCall()) {
     AssembleDeconstructFrame();
   } else if (frame_access_state()->has_frame()) {
diff --git a/src/compiler/backend/x64/instruction-selector-x64.cc b/src/compiler/backend/x64/instruction-selector-x64.cc
index 53ee75064b..111bf172cc 100644
--- a/src/compiler/backend/x64/instruction-selector-x64.cc
+++ b/src/compiler/backend/x64/instruction-selector-x64.cc
@@ -1928,6 +1928,8 @@ void InstructionSelector::EmitPrepareResults(
 
 bool InstructionSelector::IsTailCallAddressImmediate() { return true; }
 
+int InstructionSelector::GetTempsCountForTailCallFromJSFunction() { return 3; }
+
 namespace {
 
 void VisitCompareWithMemoryOperand(InstructionSelector* selector,
diff --git a/src/compiler/effect-control-linearizer.cc b/src/compiler/effect-control-linearizer.cc
index d7a0ca62dd..b95f48b2df 100644
--- a/src/compiler/effect-control-linearizer.cc
+++ b/src/compiler/effect-control-linearizer.cc
@@ -152,6 +152,7 @@ class EffectControlLinearizer {
   Node* LowerObjectIsInteger(Node* node);
   Node* LowerNumberIsSafeInteger(Node* node);
   Node* LowerObjectIsSafeInteger(Node* node);
+  Node* LowerArgumentsFrame(Node* node);
   Node* LowerArgumentsLength(Node* node);
   Node* LowerRestLength(Node* node);
   Node* LowerNewDoubleElements(Node* node);
@@ -1147,6 +1148,9 @@ bool EffectControlLinearizer::TryWireInStateEffect(Node* node,
     case IrOpcode::kObjectIsUndetectable:
       result = LowerObjectIsUndetectable(node);
       break;
+    case IrOpcode::kArgumentsFrame:
+      result = LowerArgumentsFrame(node);
+      break;
     case IrOpcode::kArgumentsLength:
       result = LowerArgumentsLength(node);
       break;
@@ -3696,9 +3700,28 @@ Node* EffectControlLinearizer::LowerToBoolean(Node* node) {
 }
 
 Node* EffectControlLinearizer::LowerArgumentsLength(Node* node) {
-  return ChangeIntPtrToSmi(
-      __ Load(MachineType::Pointer(), __ LoadFramePointer(),
-              __ IntPtrConstant(StandardFrameConstants::kArgCOffset)));
+  auto done = __ MakeLabel(MachineRepresentation::kTaggedSigned);
+  Node* frame = __ LoadFramePointer();
+
+  Node* arguments_frame = NodeProperties::GetValueInput(node, 0);
+  int formal_parameter_count = FormalParameterCountOf(node->op());
+  DCHECK_LE(0, formal_parameter_count);
+
+  // The ArgumentsLength node is computing the actual number of arguments.
+  // We have to distinguish the case when there is an arguments adaptor frame
+  // (i.e., arguments_frame != LoadFramePointer()).
+  auto if_adaptor_frame = __ MakeLabel();
+  __ GotoIf(__ TaggedEqual(arguments_frame, frame), &done,
+            __ SmiConstant(formal_parameter_count));
+  __ Goto(&if_adaptor_frame);
+
+  __ Bind(&if_adaptor_frame);
+  Node* arguments_length = __ BitcastWordToTaggedSigned(__ Load(
+      MachineType::Pointer(), arguments_frame,
+      __ IntPtrConstant(ArgumentsAdaptorFrameConstants::kLengthOffset)));
+  __ Goto(&done, arguments_length);
+  __ Bind(&done);
+  return done.PhiAt(0);
 }
 
 Node* EffectControlLinearizer::LowerRestLength(Node* node) {
@@ -3708,9 +3731,20 @@ Node* EffectControlLinearizer::LowerRestLength(Node* node) {
   auto done = __ MakeLabel(MachineRepresentation::kTaggedSigned);
   Node* frame = __ LoadFramePointer();
 
-  Node* arguments_length = ChangeIntPtrToSmi(
-      __ Load(MachineType::Pointer(), frame,
-              __ IntPtrConstant(StandardFrameConstants::kArgCOffset)));
+  Node* arguments_frame = NodeProperties::GetValueInput(node, 0);
+
+  // The RestLength node is computing the number of rest parameters,
+  // which is max(0, actual_parameter_count - formal_parameter_count).
+  // We have to distinguish the case, when there is an arguments adaptor frame
+  // (i.e., arguments_frame != LoadFramePointer()).
+  auto if_adaptor_frame = __ MakeLabel();
+  __ GotoIf(__ TaggedEqual(arguments_frame, frame), &done, __ SmiConstant(0));
+  __ Goto(&if_adaptor_frame);
+
+  __ Bind(&if_adaptor_frame);
+  Node* arguments_length = __ BitcastWordToTaggedSigned(__ Load(
+      MachineType::Pointer(), arguments_frame,
+      __ IntPtrConstant(ArgumentsAdaptorFrameConstants::kLengthOffset)));
   Node* rest_length =
       __ SmiSub(arguments_length, __ SmiConstant(formal_parameter_count));
   __ GotoIf(__ SmiLessThan(rest_length, __ SmiConstant(0)), &done,
@@ -3721,6 +3755,27 @@ Node* EffectControlLinearizer::LowerRestLength(Node* node) {
   return done.PhiAt(0);
 }
 
+Node* EffectControlLinearizer::LowerArgumentsFrame(Node* node) {
+  auto done = __ MakeLabel(MachineType::PointerRepresentation());
+
+  Node* frame = __ LoadFramePointer();
+  Node* parent_frame =
+      __ Load(MachineType::Pointer(), frame,
+              __ IntPtrConstant(StandardFrameConstants::kCallerFPOffset));
+  Node* parent_frame_type = __ Load(
+      MachineType::IntPtr(), parent_frame,
+      __ IntPtrConstant(CommonFrameConstants::kContextOrFrameTypeOffset));
+
+  __ GotoIf(__ IntPtrEqual(parent_frame_type,
+                           __ IntPtrConstant(StackFrame::TypeToMarker(
+                               StackFrame::ARGUMENTS_ADAPTOR))),
+            &done, parent_frame);
+  __ Goto(&done, frame);
+
+  __ Bind(&done);
+  return done.PhiAt(0);
+}
+
 Node* EffectControlLinearizer::LowerNewDoubleElements(Node* node) {
   AllocationType const allocation = AllocationTypeOf(node->op());
   Node* length = node->InputAt(0);
diff --git a/src/compiler/escape-analysis-reducer.cc b/src/compiler/escape-analysis-reducer.cc
index 7b1de32a3f..1ea626adbf 100644
--- a/src/compiler/escape-analysis-reducer.cc
+++ b/src/compiler/escape-analysis-reducer.cc
@@ -229,6 +229,8 @@ void EscapeAnalysisReducer::Finalize() {
                            ? params.formal_parameter_count()
                            : 0;
 
+    Node* arguments_frame = NodeProperties::GetValueInput(node, 0);
+    if (arguments_frame->opcode() != IrOpcode::kArgumentsFrame) continue;
     Node* arguments_length = NodeProperties::GetValueInput(node, 0);
     if (arguments_length->opcode() != IrOpcode::kArgumentsLength) continue;
 
diff --git a/src/compiler/js-create-lowering.cc b/src/compiler/js-create-lowering.cc
index 414977eb7d..508e2b434f 100644
--- a/src/compiler/js-create-lowering.cc
+++ b/src/compiler/js-create-lowering.cc
@@ -164,15 +164,18 @@ Reduction JSCreateLowering::ReduceJSCreateArguments(Node* node) {
         Node* const callee = NodeProperties::GetValueInput(node, 0);
         Node* const context = NodeProperties::GetContextInput(node);
         Node* effect = NodeProperties::GetEffectInput(node);
+        Node* const arguments_frame =
+            graph()->NewNode(simplified()->ArgumentsFrame());
         Node* const arguments_length =
-            graph()->NewNode(simplified()->ArgumentsLength());
+            graph()->NewNode(simplified()->ArgumentsLength(
+                                 shared.internal_formal_parameter_count()),
+                             arguments_frame);
         // Allocate the elements backing store.
         bool has_aliased_arguments = false;
         Node* const elements = effect = TryAllocateAliasedArguments(
             effect, control, context, arguments_length, shared,
             &has_aliased_arguments);
         if (elements == nullptr) return NoChange();
-
         // Load the arguments object map.
         Node* const arguments_map = jsgraph()->Constant(
             has_aliased_arguments
@@ -194,14 +197,18 @@ Reduction JSCreateLowering::ReduceJSCreateArguments(Node* node) {
       }
       case CreateArgumentsType::kUnmappedArguments: {
         Node* effect = NodeProperties::GetEffectInput(node);
+        Node* const arguments_frame =
+            graph()->NewNode(simplified()->ArgumentsFrame());
         Node* const arguments_length =
-            graph()->NewNode(simplified()->ArgumentsLength());
+            graph()->NewNode(simplified()->ArgumentsLength(
+                                 shared.internal_formal_parameter_count()),
+                             arguments_frame);
         // Allocate the elements backing store.
         Node* const elements = effect =
             graph()->NewNode(simplified()->NewArgumentsElements(
                                  CreateArgumentsType::kUnmappedArguments,
                                  shared.internal_formal_parameter_count()),
-                             arguments_length, effect);
+                             arguments_frame, arguments_length, effect);
         // Load the arguments object map.
         Node* const arguments_map =
             jsgraph()->Constant(native_context().strict_arguments_map());
@@ -220,10 +227,15 @@ Reduction JSCreateLowering::ReduceJSCreateArguments(Node* node) {
       }
       case CreateArgumentsType::kRestParameter: {
         Node* effect = NodeProperties::GetEffectInput(node);
+        Node* const arguments_frame =
+            graph()->NewNode(simplified()->ArgumentsFrame());
         Node* const arguments_length =
-            graph()->NewNode(simplified()->ArgumentsLength());
+            graph()->NewNode(simplified()->ArgumentsLength(
+                                 shared.internal_formal_parameter_count()),
+                             arguments_frame);
         Node* const rest_length = graph()->NewNode(
-            simplified()->RestLength(shared.internal_formal_parameter_count()));
+            simplified()->RestLength(shared.internal_formal_parameter_count()),
+            arguments_frame);
         // Allocate the elements backing store.
         Node* const elements = effect =
             graph()->NewNode(simplified()->NewArgumentsElements(
diff --git a/src/compiler/js-typed-lowering.cc b/src/compiler/js-typed-lowering.cc
index 82b5d345e4..76a16104cf 100644
--- a/src/compiler/js-typed-lowering.cc
+++ b/src/compiler/js-typed-lowering.cc
@@ -1573,6 +1573,13 @@ void ReduceBuiltin(JSGraph* jsgraph, Node* node, Builtin builtin, int arity,
 
   NodeProperties::ChangeOp(node, jsgraph->common()->Call(call_descriptor));
 }
+
+bool NeedsArgumentAdaptorFrame(SharedFunctionInfoRef shared, int arity) {
+  static const int sentinel = kDontAdaptArgumentsSentinel;
+  const int num_decl_parms = shared.internal_formal_parameter_count();
+  return (num_decl_parms != arity && num_decl_parms != sentinel);
+}
+
 }  // namespace
 
 Reduction JSTypedLowering::ReduceJSConstructForwardVarargs(Node* node) {
@@ -1750,24 +1757,53 @@ Reduction JSTypedLowering::ReduceJSCall(Node* node) {
     CallDescriptor::Flags flags = CallDescriptor::kNeedsFrameState;
     Node* new_target = jsgraph()->UndefinedConstant();
 
-    int formal_count = shared->internal_formal_parameter_count();
-    if (formal_count != kDontAdaptArgumentsSentinel && formal_count > arity) {
+    if (NeedsArgumentAdaptorFrame(*shared, arity)) {
       node->RemoveInput(n.FeedbackVectorIndex());
-      // Underapplication. Massage the arguments to match the expected number of
-      // arguments.
-      for (int i = arity; i < formal_count; i++) {
-        node->InsertInput(graph()->zone(), arity + 2,
-                          jsgraph()->UndefinedConstant());
-      }
 
-      // Patch {node} to a direct call.
-      node->InsertInput(graph()->zone(), formal_count + 2, new_target);
-      node->InsertInput(graph()->zone(), formal_count + 3,
-                        jsgraph()->Constant(arity));
-      NodeProperties::ChangeOp(node,
-                               common()->Call(Linkage::GetJSCallDescriptor(
-                                   graph()->zone(), false, 1 + formal_count,
-                                   flags | CallDescriptor::kCanUseRoots)));
+      // Check if it's safe to skip the arguments adaptor for {shared},
+      // that is whether the target function anyways cannot observe the
+      // actual arguments. Details can be found in this document at
+      // https://bit.ly/v8-faster-calls-with-arguments-mismatch and
+      // on the tracking bug at https://crbug.com/v8/8895
+      if (shared->is_safe_to_skip_arguments_adaptor()) {
+        // Currently we only support skipping arguments adaptor frames
+        // for strict mode functions, since there's Function.arguments
+        // legacy accessor, which is still available in sloppy mode.
+        DCHECK_EQ(LanguageMode::kStrict, shared->language_mode());
+
+        // Massage the arguments to match the expected number of arguments.
+        int expected_argument_count = shared->internal_formal_parameter_count();
+        for (; arity > expected_argument_count; --arity) {
+          node->RemoveInput(arity + 1);
+        }
+        for (; arity < expected_argument_count; ++arity) {
+          node->InsertInput(graph()->zone(), arity + 2,
+                            jsgraph()->UndefinedConstant());
+        }
+
+        // Patch {node} to a direct call.
+        node->InsertInput(graph()->zone(), arity + 2, new_target);
+        node->InsertInput(graph()->zone(), arity + 3,
+                          jsgraph()->Constant(arity));
+        NodeProperties::ChangeOp(node,
+                                 common()->Call(Linkage::GetJSCallDescriptor(
+                                     graph()->zone(), false, 1 + arity,
+                                     flags | CallDescriptor::kCanUseRoots)));
+      } else {
+        // Patch {node} to an indirect call via the ArgumentsAdaptorTrampoline.
+        Callable callable = CodeFactory::ArgumentAdaptor(isolate());
+        node->InsertInput(graph()->zone(), 0,
+                          jsgraph()->HeapConstant(callable.code()));
+        node->InsertInput(graph()->zone(), 2, new_target);
+        node->InsertInput(graph()->zone(), 3, jsgraph()->Constant(arity));
+        node->InsertInput(
+            graph()->zone(), 4,
+            jsgraph()->Constant(shared->internal_formal_parameter_count()));
+        NodeProperties::ChangeOp(
+            node,
+            common()->Call(Linkage::GetStubCallDescriptor(
+                graph()->zone(), callable.descriptor(), 1 + arity, flags)));
+      }
     } else if (shared->HasBuiltinId() &&
                Builtins::IsCpp(shared->builtin_id())) {
       // Patch {node} to a direct CEntry call.
diff --git a/src/compiler/opcodes.h b/src/compiler/opcodes.h
index 912bd7b5ce..ac33fde957 100644
--- a/src/compiler/opcodes.h
+++ b/src/compiler/opcodes.h
@@ -395,6 +395,7 @@
 #define SIMPLIFIED_OTHER_OP_LIST(V)     \
   V(Allocate)                           \
   V(AllocateRaw)                        \
+  V(ArgumentsFrame)                     \
   V(ArgumentsLength)                    \
   V(AssertType)                         \
   V(BooleanNot)                         \
diff --git a/src/compiler/simplified-lowering.cc b/src/compiler/simplified-lowering.cc
index 1c07a23dde..f925fac50f 100644
--- a/src/compiler/simplified-lowering.cc
+++ b/src/compiler/simplified-lowering.cc
@@ -3717,6 +3717,10 @@ class RepresentationSelector {
         VisitObjectIs<T>(node, Type::Undetectable(), lowering);
         return;
       }
+      case IrOpcode::kArgumentsFrame: {
+        SetOutput<T>(node, MachineType::PointerRepresentation());
+        return;
+      }
       case IrOpcode::kArgumentsLength:
       case IrOpcode::kRestLength: {
         SetOutput<T>(node, MachineRepresentation::kTaggedSigned);
diff --git a/src/compiler/simplified-operator.cc b/src/compiler/simplified-operator.cc
index 9c4f8f083a..bcbb59dfee 100644
--- a/src/compiler/simplified-operator.cc
+++ b/src/compiler/simplified-operator.cc
@@ -1005,6 +1005,13 @@ struct SimplifiedOperatorGlobalCache final {
   ChangeFloat64ToTaggedOperator<CheckForMinusZeroMode::kDontCheckForMinusZero>
       kChangeFloat64ToTaggedDontCheckForMinusZeroOperator;
 
+  struct ArgumentsFrameOperator final : public Operator {
+    ArgumentsFrameOperator()
+        : Operator(IrOpcode::kArgumentsFrame, Operator::kPure, "ArgumentsFrame",
+                   0, 0, 0, 1, 0, 0) {}
+  };
+  ArgumentsFrameOperator kArgumentsFrame;
+
   template <CheckForMinusZeroMode kMode>
   struct CheckedInt32MulOperator final
       : public Operator1<CheckForMinusZeroMode> {
@@ -1238,6 +1245,7 @@ SimplifiedOperatorBuilder::SimplifiedOperatorBuilder(Zone* zone)
 PURE_OP_LIST(GET_FROM_CACHE)
 EFFECT_DEPENDENT_OP_LIST(GET_FROM_CACHE)
 CHECKED_OP_LIST(GET_FROM_CACHE)
+GET_FROM_CACHE(ArgumentsFrame)
 GET_FROM_CACHE(FindOrderedHashMapEntry)
 GET_FROM_CACHE(FindOrderedHashMapEntryForInt32Key)
 GET_FROM_CACHE(LoadFieldByIndex)
@@ -1657,12 +1665,14 @@ const Operator* SimplifiedOperatorBuilder::TransitionElementsKind(
       transition);                                    // parameter
 }
 
-const Operator* SimplifiedOperatorBuilder::ArgumentsLength() {
-  return zone()->New<Operator>(    // --
-      IrOpcode::kArgumentsLength,  // opcode
-      Operator::kPure,             // flags
-      "ArgumentsLength",           // name
-      0, 0, 0, 1, 0, 0);           // counts
+const Operator* SimplifiedOperatorBuilder::ArgumentsLength(
+    int formal_parameter_count) {
+  return zone()->New<Operator1<int>>(  // --
+      IrOpcode::kArgumentsLength,      // opcode
+      Operator::kPure,                 // flags
+      "ArgumentsLength",               // name
+      1, 0, 0, 1, 0, 0,                // counts
+      formal_parameter_count);         // parameter
 }
 
 const Operator* SimplifiedOperatorBuilder::RestLength(
diff --git a/src/compiler/simplified-operator.h b/src/compiler/simplified-operator.h
index d7a5901448..3171f0d714 100644
--- a/src/compiler/simplified-operator.h
+++ b/src/compiler/simplified-operator.h
@@ -1019,7 +1019,8 @@ class V8_EXPORT_PRIVATE SimplifiedOperatorBuilder final
   const Operator* NumberIsSafeInteger();
   const Operator* ObjectIsInteger();
 
-  const Operator* ArgumentsLength();
+  const Operator* ArgumentsFrame();
+  const Operator* ArgumentsLength(int formal_parameter_count);
   const Operator* RestLength(int formal_parameter_count);
 
   const Operator* NewDoubleElements(AllocationType);
diff --git a/src/compiler/typer.cc b/src/compiler/typer.cc
index 529f1cc7bb..17089dd25c 100644
--- a/src/compiler/typer.cc
+++ b/src/compiler/typer.cc
@@ -2314,6 +2314,10 @@ Type Typer::Visitor::TypeRestLength(Node* node) {
   return TypeCache::Get()->kArgumentsLengthType;
 }
 
+Type Typer::Visitor::TypeArgumentsFrame(Node* node) {
+  return Type::ExternalPointer();
+}
+
 Type Typer::Visitor::TypeNewDoubleElements(Node* node) {
   return Type::OtherInternal();
 }
diff --git a/src/compiler/verifier.cc b/src/compiler/verifier.cc
index f33edaa6c0..7e3903ddcf 100644
--- a/src/compiler/verifier.cc
+++ b/src/compiler/verifier.cc
@@ -1241,6 +1241,9 @@ void Verifier::Visitor::Check(Node* node, const AllNodes& all) {
     case IrOpcode::kRestLength:
       CheckTypeIs(node, TypeCache::Get()->kArgumentsLengthType);
       break;
+    case IrOpcode::kArgumentsFrame:
+      CheckTypeIs(node, Type::ExternalPointer());
+      break;
     case IrOpcode::kNewDoubleElements:
     case IrOpcode::kNewSmiOrObjectElements:
       CheckValueInputIs(node, 0,
diff --git a/src/compiler/wasm-compiler.cc b/src/compiler/wasm-compiler.cc
index 88ca600271..457609843d 100644
--- a/src/compiler/wasm-compiler.cc
+++ b/src/compiler/wasm-compiler.cc
@@ -6943,33 +6943,43 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
       // === JS Functions with mismatching arity ===============================
       // =======================================================================
       case WasmImportCallKind::kJSFunctionArityMismatch: {
-        int pushed_count = std::max(expected_arity, wasm_count);
-        base::SmallVector<Node*, 16> args(pushed_count + 7);
+        base::SmallVector<Node*, 16> args(wasm_count + 9);
         int pos = 0;
+        Node* function_context =
+            gasm_->LoadContextFromJSFunction(callable_node);
+        args[pos++] =
+            gasm_->GetBuiltinPointerTarget(Builtin::kArgumentsAdaptorTrampoline);
+        args[pos++] = callable_node;                         // target callable
+        args[pos++] = undefined_node;                        // new target
+        args[pos++] = mcgraph()->Int32Constant(wasm_count);  // argument count
+
+        // Load shared function info, and then the formal parameter count.
+        Node* shared_function_info =
+            gasm_->LoadSharedFunctionInfo(callable_node);
+        Node* formal_param_count =
+            gasm_->Load(MachineType::Uint16(), shared_function_info,
+                        wasm::ObjectAccess::
+                            FormalParameterCountOffsetInSharedFunctionInfo());
+        args[pos++] = formal_param_count;
 
-        args[pos++] = callable_node;  // target callable.
         // Determine receiver at runtime.
         args[pos++] =
             BuildReceiverNode(callable_node, native_context, undefined_node);
 
-        // Convert wasm numbers to JS values.
-        pos = AddArgumentNodes(base::VectorOf(args), pos, wasm_count, sig_);
-        for (int i = wasm_count; i < expected_arity; ++i) {
-          args[pos++] = undefined_node;
-        }
-        args[pos++] = undefined_node;                        // new target
-        args[pos++] = Int32Constant(wasm_count);             // argument count
+        auto call_descriptor = Linkage::GetStubCallDescriptor(
+            mcgraph()->zone(), ArgumentsAdaptorDescriptor{}, 1 + wasm_count,
+            CallDescriptor::kNoFlags, Operator::kNoProperties,
+            StubCallMode::kCallBuiltinPointer);
 
-        Node* function_context =
-            gasm_->LoadContextFromJSFunction(callable_node);
+        // Convert wasm numbers to JS values.
+        pos = AddArgumentNodes(VectorOf(args), pos, wasm_count, sig_);
         args[pos++] = function_context;
         args[pos++] = effect();
         args[pos++] = control();
-        DCHECK_EQ(pos, args.size());
 
-        auto call_descriptor = Linkage::GetJSCallDescriptor(
-            graph()->zone(), false, pushed_count + 1, CallDescriptor::kNoFlags);
-        call = gasm_->Call(call_descriptor, pos, args.begin());
+        DCHECK_EQ(pos, args.size());
+        call = graph()->NewNode(mcgraph()->common()->Call(call_descriptor), pos,
+                                args.begin());
         break;
       }
       // =======================================================================
diff --git a/src/debug/debug-frames.cc b/src/debug/debug-frames.cc
index bcb8da6652..6697e99f85 100644
--- a/src/debug/debug-frames.cc
+++ b/src/debug/debug-frames.cc
@@ -40,6 +40,7 @@ FrameInspector::FrameInspector(CommonFrame* frame, int inlined_frame_index,
 #else
   JavaScriptFrame* js_frame = javascript_frame();
 #endif  // V8_ENABLE_WEBASSEMBLY
+  has_adapted_arguments_ = js_frame && js_frame->has_adapted_arguments();
   is_optimized_ = frame_->is_optimized();
 
   // Calculate the deoptimized frame.
@@ -55,7 +56,8 @@ FrameInspector::FrameInspector(CommonFrame* frame, int inlined_frame_index,
 FrameInspector::~FrameInspector() = default;
 
 JavaScriptFrame* FrameInspector::javascript_frame() {
-  return JavaScriptFrame::cast(frame_);
+  return frame_->is_arguments_adaptor() ? ArgumentsAdaptorFrame::cast(frame_)
+                                        : JavaScriptFrame::cast(frame_);
 }
 
 Handle<Object> FrameInspector::GetParameter(int index) {
diff --git a/src/debug/debug-frames.h b/src/debug/debug-frames.h
index 5197f86298..58f915fc9f 100644
--- a/src/debug/debug-frames.h
+++ b/src/debug/debug-frames.h
@@ -60,6 +60,7 @@ class FrameInspector {
   Handle<JSFunction> function_;
   int source_position_ = -1;
   bool is_optimized_ = false;
+  bool has_adapted_arguments_ = false;
   bool is_constructor_ = false;
 };
 
diff --git a/src/deoptimizer/deoptimizer-cfi-builtins.cc b/src/deoptimizer/deoptimizer-cfi-builtins.cc
index 92bce90095..4bbd68aa6b 100644
--- a/src/deoptimizer/deoptimizer-cfi-builtins.cc
+++ b/src/deoptimizer/deoptimizer-cfi-builtins.cc
@@ -12,6 +12,7 @@ void Builtins_ContinueToCodeStubBuiltinWithResult();
 void Builtins_ContinueToCodeStubBuiltin();
 void Builtins_ContinueToJavaScriptBuiltinWithResult();
 void Builtins_ContinueToJavaScriptBuiltin();
+void arguments_adaptor_deopt_addr();
 void construct_stub_create_deopt_addr();
 void construct_stub_invoke_deopt_addr();
 void Builtins_BaselineOrInterpreterEnterAtBytecode();
@@ -30,6 +31,7 @@ constexpr function_ptr builtins[] = {
     &Builtins_ContinueToCodeStubBuiltin,
     &Builtins_ContinueToJavaScriptBuiltinWithResult,
     &Builtins_ContinueToJavaScriptBuiltin,
+    &arguments_adaptor_deopt_addr,
     &construct_stub_create_deopt_addr,
     &construct_stub_invoke_deopt_addr,
     &Builtins_BaselineOrInterpreterEnterAtBytecode,
diff --git a/src/deoptimizer/deoptimizer.cc b/src/deoptimizer/deoptimizer.cc
index 296c946e4d..ee99509eb3 100644
--- a/src/deoptimizer/deoptimizer.cc
+++ b/src/deoptimizer/deoptimizer.cc
@@ -1023,13 +1023,7 @@ void Deoptimizer::DoComputeUnoptimizedFrame(TranslatedFrame* translated_frame,
 
   const int parameters_count = InternalFormalParameterCountWithReceiver(shared);
 
-  // If this is the bottom most frame or the previous frame was the arguments
-  // adaptor fake frame, then we already have extra arguments in the stack
-  // (including any extra padding). Therefore we should not try to add any
-  // padding.
-  bool should_pad_arguments =
-      !is_bottommost && (translated_state_.frames()[frame_index - 1]).kind() !=
-                            TranslatedFrame::kArgumentsAdaptor;
+  bool should_pad_arguments = true;
 
   const int locals_count = translated_frame->height();
   UnoptimizedFrameInfo frame_info = UnoptimizedFrameInfo::Precise(
@@ -1319,60 +1313,101 @@ void Deoptimizer::DoComputeArgumentsAdaptorFrame(
   CHECK_GT(frame_index, 0);
   CHECK_NULL(output_[frame_index]);
 
-  // During execution, V8 does not understand arguments adaptor frames anymore,
-  // so during deoptimization we only push the extra arguments (arguments with
-  // index greater than the formal parameter count). Therefore we call this
-  // TranslatedFrame the fake adaptor frame.
-  // For more info, see the design document:
-  // https://docs.google.com/document/d/150wGaUREaZI6YWqOQFD5l2mWQXaPbbZjcAIJLOFrzMs
-
   TranslatedFrame::iterator value_iterator = translated_frame->begin();
-  const int argument_count_without_receiver = translated_frame->height() - 1;
-  const int formal_parameter_count =
-      translated_frame->raw_shared_info().internal_formal_parameter_count();
-  const int extra_argument_count =
-      argument_count_without_receiver - formal_parameter_count;
-  // The number of pushed arguments is the maximum of the actual argument count
-  // and the formal parameter count + the receiver.
-  const int padding = ArgumentPaddingSlots(
-      std::max(argument_count_without_receiver, formal_parameter_count) + 1);
-  const int output_frame_size =
-      (std::max(0, extra_argument_count) + padding) * kSystemPointerSize;
+  const bool is_bottommost = (0 == frame_index);
+
+  const int parameters_count = translated_frame->height();
+  ArgumentsAdaptorFrameInfo frame_info =
+      ArgumentsAdaptorFrameInfo::Precise(parameters_count);
+  const uint32_t output_frame_size = frame_info.frame_size_in_bytes();
+
+  TranslatedFrame::iterator function_iterator = value_iterator++;
   if (verbose_tracing_enabled()) {
-    PrintF(trace_scope_->file(),
-           "  translating arguments adaptor => variable_size=%d\n",
-           output_frame_size);
+    PrintF(trace_scope()->file(),
+           "  translating arguments adaptor => variable_frame_size=%d, "
+           "frame_size=%d\n",
+           frame_info.frame_size_in_bytes_without_fixed(), output_frame_size);
   }
 
   // Allocate and store the output frame description.
   FrameDescription* output_frame = new (output_frame_size)
-      FrameDescription(output_frame_size, argument_count_without_receiver);
+      FrameDescription(output_frame_size, parameters_count);
+  FrameWriter frame_writer(this, output_frame, verbose_trace_scope());
+
+  // Arguments adaptor can not be topmost.
+  CHECK(frame_index < output_count_ - 1);
+  CHECK_NULL(output_[frame_index]);
+  output_[frame_index] = output_frame;
+
   // The top address of the frame is computed from the previous frame's top and
   // this frame's size.
   const intptr_t top_address =
-      output_[frame_index - 1]->GetTop() - output_frame_size;
+      is_bottommost ? caller_frame_top_ - output_frame_size
+                    : output_[frame_index - 1]->GetTop() - output_frame_size;
   output_frame->SetTop(top_address);
-  // This is not a real frame, we take PC and FP values from the parent frame.
-  output_frame->SetPc(output_[frame_index - 1]->GetPc());
-  output_frame->SetFp(output_[frame_index - 1]->GetFp());
-  output_[frame_index] = output_frame;
-
-  FrameWriter frame_writer(this, output_frame, verbose_trace_scope());
 
   ReadOnlyRoots roots(isolate());
-  for (int i = 0; i < padding; ++i) {
+  if (ShouldPadArguments(parameters_count)) {
     frame_writer.PushRawObject(roots.the_hole_value(), "padding\n");
   }
 
-  if (extra_argument_count > 0) {
-    // The receiver and arguments with index below the formal parameter
-    // count are in the fake adaptor frame, because they are used to create the
-    // arguments object. We should however not push them, since the interpreter
-    // frame with do that.
-    value_iterator++;  // Skip function.
-    value_iterator++;  // Skip receiver.
-    for (int i = 0; i < formal_parameter_count; i++) value_iterator++;
-    frame_writer.PushStackJSArguments(value_iterator, extra_argument_count);
+  // Compute the incoming parameter translation.
+  frame_writer.PushStackJSArguments(value_iterator, parameters_count);
+
+  DCHECK_EQ(output_frame->GetLastArgumentSlotOffset(),
+            frame_writer.top_offset());
+
+  // Read caller's PC from the previous frame.
+  if (is_bottommost) {
+    frame_writer.PushBottommostCallerPc(caller_pc_);
+  } else {
+    frame_writer.PushApprovedCallerPc(output_[frame_index - 1]->GetPc());
+  }
+
+  // Read caller's FP from the previous frame, and set this frame's FP.
+  const intptr_t caller_fp =
+      is_bottommost ? caller_fp_ : output_[frame_index - 1]->GetFp();
+  frame_writer.PushCallerFp(caller_fp);
+
+  intptr_t fp_value = top_address + frame_writer.top_offset();
+  output_frame->SetFp(fp_value);
+
+  if (FLAG_enable_embedded_constant_pool) {
+    // Read the caller's constant pool from the previous frame.
+    const intptr_t caller_cp =
+        is_bottommost ? caller_constant_pool_
+                      : output_[frame_index - 1]->GetConstantPool();
+    frame_writer.PushCallerConstantPool(caller_cp);
+  }
+
+  // A marker value is used in place of the context.
+  intptr_t marker = StackFrame::TypeToMarker(StackFrame::ARGUMENTS_ADAPTOR);
+  frame_writer.PushRawValue(marker, "context (adaptor sentinel)\n");
+
+  // The function was mentioned explicitly in the ARGUMENTS_ADAPTOR_FRAME.
+  frame_writer.PushTranslatedValue(function_iterator, "function\n");
+
+  // Number of incoming arguments.
+  const uint32_t parameters_count_without_receiver = parameters_count - 1;
+  frame_writer.PushRawObject(Smi::FromInt(parameters_count_without_receiver),
+                             "argc\n");
+
+  frame_writer.PushRawObject(roots.the_hole_value(), "padding\n");
+
+  CHECK_EQ(translated_frame->end(), value_iterator);
+  DCHECK_EQ(0, frame_writer.top_offset());
+
+  Builtins* builtins = isolate_->builtins();
+  Code adaptor_trampoline =
+      builtins->code(Builtin::kArgumentsAdaptorTrampoline);
+  intptr_t pc_value = static_cast<intptr_t>(
+      adaptor_trampoline.InstructionStart() +
+      isolate_->heap()->arguments_adaptor_deopt_pc_offset().value());
+  output_frame->SetPc(pc_value);
+  if (FLAG_enable_embedded_constant_pool) {
+    intptr_t constant_pool_value =
+        static_cast<intptr_t>(adaptor_trampoline.constant_pool());
+    output_frame->SetConstantPool(constant_pool_value);
   }
 }
 
@@ -2044,6 +2079,7 @@ unsigned Deoptimizer::ComputeInputFrameSize() const {
 // static
 unsigned Deoptimizer::ComputeIncomingArgumentSize(SharedFunctionInfo shared) {
   int parameter_slots = InternalFormalParameterCountWithReceiver(shared);
+  if (ShouldPadArguments(parameter_slots)) parameter_slots++;
   return parameter_slots * kSystemPointerSize;
 }
 
diff --git a/src/deoptimizer/frame-description.h b/src/deoptimizer/frame-description.h
index f7e79aec6c..8691d7d9d7 100644
--- a/src/deoptimizer/frame-description.h
+++ b/src/deoptimizer/frame-description.h
@@ -119,10 +119,7 @@ class FrameDescription {
   }
 
   Address GetFramePointerAddress() {
-    // We should not pad arguments in the bottom frame, since this
-    // already contain a padding if necessary and it might contain
-    // extra arguments (actual argument count > parameter count).
-    const bool pad_arguments_bottom_frame = false;
+    const bool pad_arguments_bottom_frame = true;
     int fp_offset = GetLastArgumentSlotOffset(pad_arguments_bottom_frame) -
                     StandardFrameConstants::kCallerSPOffset;
     return reinterpret_cast<Address>(GetFrameSlotPointer(fp_offset));
diff --git a/src/deoptimizer/translated-state.cc b/src/deoptimizer/translated-state.cc
index b51658f8e6..e9aa1fe13b 100644
--- a/src/deoptimizer/translated-state.cc
+++ b/src/deoptimizer/translated-state.cc
@@ -900,6 +900,30 @@ void TranslatedFrame::AdvanceIterator(
   }
 }
 
+Address TranslatedState::ComputeArgumentsPosition(Address input_frame_pointer,
+                                                  int* length) {
+  Address parent_frame_pointer = *reinterpret_cast<Address*>(
+      input_frame_pointer + StandardFrameConstants::kCallerFPOffset);
+  intptr_t parent_frame_type = Memory<intptr_t>(
+      parent_frame_pointer + CommonFrameConstants::kContextOrFrameTypeOffset);
+
+  Address arguments_frame;
+  if (parent_frame_type ==
+      StackFrame::TypeToMarker(StackFrame::ARGUMENTS_ADAPTOR)) {
+    if (length)
+      *length = Smi::cast(*FullObjectSlot(
+                              parent_frame_pointer +
+                              ArgumentsAdaptorFrameConstants::kLengthOffset))
+                    .value();
+    arguments_frame = parent_frame_pointer;
+  } else {
+    if (length) *length = formal_parameter_count_;
+    arguments_frame = input_frame_pointer;
+  }
+
+  return arguments_frame;
+}
+
 // Creates translated values for an arguments backing store, or the backing
 // store for rest parameters depending on the given {type}. The TranslatedValue
 // objects for the fields are not read from the TranslationArrayIterator, but
@@ -909,10 +933,12 @@ void TranslatedState::CreateArgumentsElementsTranslatedValues(
     int frame_index, Address input_frame_pointer, CreateArgumentsType type,
     FILE* trace_file) {
   TranslatedFrame& frame = frames_[frame_index];
-  int length =
-      type == CreateArgumentsType::kRestParameter
-          ? std::max(0, actual_argument_count_ - formal_parameter_count_)
-          : actual_argument_count_;
+  int arguments_length;
+  Address arguments_frame =
+      ComputeArgumentsPosition(input_frame_pointer, &arguments_length);
+  int length = type == CreateArgumentsType::kRestParameter
+                   ? std::max(0, arguments_length - formal_parameter_count_)
+                   : arguments_length;
   int object_index = static_cast<int>(object_positions_.size());
   int value_index = static_cast<int>(frame.values_.size());
   if (trace_file != nullptr) {
@@ -945,9 +971,6 @@ void TranslatedState::CreateArgumentsElementsTranslatedValues(
   for (int i = 0; i < argc; i++) {
     // Skip the receiver.
     int offset = argc - i - 1;
-    Address arguments_frame = offset > formal_parameter_count_
-                                  ? stack_frame_pointer_
-                                  : input_frame_pointer;
     Address argument_slot = arguments_frame +
                             CommonFrameConstants::kFixedFrameSizeAboveFp +
                             offset * kSystemPointerSize;
@@ -1011,11 +1034,13 @@ int TranslatedState::CreateNextTranslatedValue(
     }
 
     case TranslationOpcode::ARGUMENTS_LENGTH: {
+      int arguments_length;
+      ComputeArgumentsPosition(fp, &arguments_length);
       if (trace_file != nullptr) {
         PrintF(trace_file, "arguments length field (length = %d)",
-               actual_argument_count_);
+               arguments_length);
       }
-      frame.Add(TranslatedValue::NewInt32(this, actual_argument_count_));
+      frame.Add(TranslatedValue::NewInt32(this, arguments_length));
       return 0;
     }
 
@@ -1295,7 +1320,7 @@ TranslatedState::TranslatedState(const JavaScriptFrame* frame)
   DCHECK(!data.is_null() && deopt_index != Safepoint::kNoDeoptimizationIndex);
   TranslationArrayIterator it(data.TranslationByteArray(),
                               data.TranslationIndex(deopt_index).value());
-  int actual_argc = frame->GetActualArgumentCount();
+  int actual_argc = 0;
   Init(frame->isolate(), frame->fp(), frame->fp(), &it, data.LiteralArray(),
        nullptr /* registers */, nullptr /* trace file */,
        frame->function().shared().internal_formal_parameter_count(),
diff --git a/src/deoptimizer/translated-state.h b/src/deoptimizer/translated-state.h
index 799cb5b18c..28773054c9 100644
--- a/src/deoptimizer/translated-state.h
+++ b/src/deoptimizer/translated-state.h
@@ -405,6 +405,7 @@ class TranslatedState {
                                 FixedArray literal_array, Address fp,
                                 RegisterValues* registers, FILE* trace_file);
   Address DecompressIfNeeded(intptr_t value);
+  Address ComputeArgumentsPosition(Address input_frame_pointer, int* length);
   void CreateArgumentsElementsTranslatedValues(int frame_index,
                                                Address input_frame_pointer,
                                                CreateArgumentsType type,
diff --git a/src/execution/frame-constants.h b/src/execution/frame-constants.h
index a6aed32ee9..9a47b5a68c 100644
--- a/src/execution/frame-constants.h
+++ b/src/execution/frame-constants.h
@@ -196,6 +196,15 @@ class TypedFrameConstants : public CommonFrameConstants {
 #define DEFINE_TYPED_FRAME_SIZES(count) \
   DEFINE_FRAME_SIZES(TypedFrameConstants, count)
 
+class ArgumentsAdaptorFrameConstants : public TypedFrameConstants {
+ public:
+  // FP-relative.
+  static constexpr int kFunctionOffset = TYPED_FRAME_PUSHED_VALUE_OFFSET(0);
+  static constexpr int kLengthOffset = TYPED_FRAME_PUSHED_VALUE_OFFSET(1);
+  static constexpr int kPaddingOffset = TYPED_FRAME_PUSHED_VALUE_OFFSET(2);
+  DEFINE_TYPED_FRAME_SIZES(3);
+};
+
 class BuiltinFrameConstants : public TypedFrameConstants {
  public:
   // FP-relative.
diff --git a/src/execution/frames-inl.h b/src/execution/frames-inl.h
index 6f538c7346..1dd96214fd 100644
--- a/src/execution/frames-inl.h
+++ b/src/execution/frames-inl.h
@@ -178,6 +178,12 @@ inline Address CommonFrame::ComputeConstantPoolAddress(Address fp) {
   return fp + StandardFrameConstants::kConstantPoolOffset;
 }
 
+inline bool CommonFrame::IsArgumentsAdaptorFrame(Address fp) {
+  intptr_t frame_type =
+      base::Memory<intptr_t>(fp + TypedFrameConstants::kFrameTypeOffset);
+  return frame_type == StackFrame::TypeToMarker(StackFrame::ARGUMENTS_ADAPTOR);
+}
+
 inline bool CommonFrameWithJSLinkage::IsConstructFrame(Address fp) {
   intptr_t frame_type =
       base::Memory<intptr_t>(fp + TypedFrameConstants::kFrameTypeOffset);
@@ -189,21 +195,21 @@ inline JavaScriptFrame::JavaScriptFrame(StackFrameIteratorBase* iterator)
 
 Address CommonFrameWithJSLinkage::GetParameterSlot(int index) const {
   DCHECK_LE(-1, index);
-  DCHECK_LT(index,
-            std::max(GetActualArgumentCount(), ComputeParametersCount()));
+  DCHECK(index < ComputeParametersCount() ||
+         ComputeParametersCount() == kDontAdaptArgumentsSentinel);
   int param_count = ComputeParametersCount();
   int parameter_offset = (param_count - index - 1) * kSystemPointerSize;
   return caller_sp() + parameter_offset;
 }
 
-inline int CommonFrameWithJSLinkage::GetActualArgumentCount() const {
-  return 0;
-}
-
 inline void JavaScriptFrame::set_receiver(Object value) {
   base::Memory<Address>(GetParameterSlot(-1)) = value.ptr();
 }
 
+inline bool JavaScriptFrame::has_adapted_arguments() const {
+  return IsArgumentsAdaptorFrame(caller_fp());
+}
+
 inline Object JavaScriptFrame::function_slot_object() const {
   const int offset = StandardFrameConstants::kFunctionOffset;
   return Object(base::Memory<Address>(fp() + offset));
@@ -224,6 +230,9 @@ inline InterpretedFrame::InterpretedFrame(StackFrameIteratorBase* iterator)
 inline BaselineFrame::BaselineFrame(StackFrameIteratorBase* iterator)
     : UnoptimizedFrame(iterator) {}
 
+inline ArgumentsAdaptorFrame::ArgumentsAdaptorFrame(StackFrameIteratorBase* iterator)
+    : JavaScriptFrame(iterator) {}
+
 inline BuiltinFrame::BuiltinFrame(StackFrameIteratorBase* iterator)
     : TypedFrameWithJSLinkage(iterator) {}
 
@@ -289,15 +298,17 @@ inline JavaScriptFrame* JavaScriptFrameIterator::frame() const {
 
 inline JavaScriptFrame* JavaScriptFrameIterator::Reframe() {
   StackFrame* frame = iterator_.Reframe();
-  return JavaScriptFrame::cast(frame);
+  DCHECK(frame->is_java_script() || frame->is_arguments_adaptor());
+  return static_cast<JavaScriptFrame*>(frame);
 }
 
 inline CommonFrame* StackTraceFrameIterator::frame() const {
   StackFrame* frame = iterator_.frame();
 #if V8_ENABLE_WEBASSEMBLY
-  DCHECK(frame->is_java_script() || frame->is_wasm());
+  DCHECK(frame->is_java_script() || frame->is_arguments_adaptor() ||
+         frame->is_wasm());
 #else
-  DCHECK(frame->is_java_script());
+  DCHECK(frame->is_java_script() || frame->is_arguments_adaptor());
 #endif  // V8_ENABLE_WEBASSEMBLY
   return static_cast<CommonFrame*>(frame);
 }
diff --git a/src/execution/frames.cc b/src/execution/frames.cc
index fb56e34425..1661049358 100644
--- a/src/execution/frames.cc
+++ b/src/execution/frames.cc
@@ -443,6 +443,15 @@ bool SafeStackFrameIterator::IsValidCaller(StackFrame* frame) {
     Address caller_fp =
         Memory<Address>(frame->fp() + EntryFrameConstants::kCallerFPOffset);
     if (!IsValidExitFrame(caller_fp)) return false;
+  } else if (frame->is_arguments_adaptor()) {
+    // See ArgumentsAdaptorFrame::GetCallerStackPointer. It assumes that
+    // the number of arguments is stored on stack as Smi. We need to check
+    // that it really an Smi.
+    Object number_of_args =
+        reinterpret_cast<ArgumentsAdaptorFrame*>(frame)->GetExpression(0);
+    if (!number_of_args.IsSmi()) {
+      return false;
+    }
   }
   frame->ComputeCallerState(&state);
   return IsValidStackAddress(state.sp) && IsValidStackAddress(state.fp) &&
@@ -648,6 +657,7 @@ StackFrame::Type StackFrame::ComputeType(const StackFrameIteratorBase* iterator,
     case STUB:
     case INTERNAL:
     case CONSTRUCT:
+    case ARGUMENTS_ADAPTOR:
 #if V8_ENABLE_WEBASSEMBLY
     case WASM_TO_JS:
     case WASM:
@@ -1002,6 +1012,7 @@ void CommonFrame::IterateCompiledFrame(RootVisitor* v) const {
       case JAVA_SCRIPT_BUILTIN_CONTINUATION:
       case JAVA_SCRIPT_BUILTIN_CONTINUATION_WITH_CATCH:
       case BUILTIN_EXIT:
+      case ARGUMENTS_ADAPTOR:
       case STUB:
       case INTERNAL:
       case CONSTRUCT:
@@ -1137,7 +1148,12 @@ void JavaScriptFrame::SetParameterValue(int index, Object value) const {
 }
 
 bool JavaScriptFrame::IsConstructor() const {
-  return IsConstructFrame(caller_fp());
+  Address fp = caller_fp();
+  if (has_adapted_arguments()) {
+    // Skip the arguments adaptor frame and look at the real caller.
+    fp = Memory<Address>(fp + StandardFrameConstants::kCallerFPOffset);
+  }
+  return IsConstructFrame(fp);
 }
 
 bool JavaScriptFrame::HasInlinedFrames() const {
@@ -1330,11 +1346,6 @@ int CommonFrameWithJSLinkage::ComputeParametersCount() const {
   return function().shared().internal_formal_parameter_count();
 }
 
-int JavaScriptFrame::GetActualArgumentCount() const {
-  return static_cast<int>(
-      Memory<intptr_t>(fp() + StandardFrameConstants::kArgCOffset));
-}
-
 Handle<FixedArray> CommonFrameWithJSLinkage::GetParameters() const {
   if (V8_LIKELY(!FLAG_detailed_error_stack_trace)) {
     return isolate()->factory()->empty_fixed_array();
@@ -1850,6 +1861,15 @@ void BaselineFrame::PatchContext(Context value) {
       value.ptr();
 }
 
+int ArgumentsAdaptorFrame::ComputeParametersCount() const {
+  const int offset = ArgumentsAdaptorFrameConstants::kLengthOffset;
+  return Smi::ToInt(Object(base::Memory<Address>(fp() + offset)));
+}
+
+Code ArgumentsAdaptorFrame::unchecked_code() const {
+  return isolate()->builtins()->code(Builtin::kArgumentsAdaptorTrampoline);
+}
+
 JSFunction BuiltinFrame::function() const {
   const int offset = BuiltinFrameConstants::kFunctionOffset;
   return JSFunction::cast(Object(base::Memory<Address>(fp() + offset)));
@@ -2184,6 +2204,34 @@ void JavaScriptFrame::Print(StringStream* accumulator, PrintMode mode,
   accumulator->Add("}\n\n");
 }
 
+void ArgumentsAdaptorFrame::Print(StringStream* accumulator, PrintMode mode,
+                                  int index) const {
+  int actual = ComputeParametersCount();
+  int expected = -1;
+  JSFunction function = this->function();
+  expected = function.shared().internal_formal_parameter_count();
+
+  PrintIndex(accumulator, mode, index);
+  accumulator->Add("arguments adaptor frame: %d->%d", actual, expected);
+  if (mode == OVERVIEW) {
+    accumulator->Add("\n");
+    return;
+  }
+  accumulator->Add(" {\n");
+
+  // Print actual arguments.
+  if (actual > 0) accumulator->Add("  // actual arguments\n");
+  for (int i = 0; i < actual; i++) {
+    accumulator->Add("  [%02d] : %o", i, GetParameter(i));
+    if (expected != -1 && i >= expected) {
+      accumulator->Add("  // not passed to callee");
+    }
+    accumulator->Add("\n");
+  }
+
+  accumulator->Add("}\n\n");
+}
+
 void EntryFrame::Iterate(RootVisitor* v) const {
   IteratePc(v, pc_address(), constant_pool_address(), LookupCode());
 }
@@ -2328,6 +2376,17 @@ uint32_t UnoptimizedFrameInfo::GetStackSizeForAdditionalArguments(
          kSystemPointerSize;
 }
 
+ArgumentsAdaptorFrameInfo::ArgumentsAdaptorFrameInfo(int translation_height) {
+  // Note: This is according to the Translation's notion of 'parameters' which
+  // differs to that of the SharedFunctionInfo, e.g. by including the receiver.
+  const int parameters_count = translation_height;
+  frame_size_in_bytes_without_fixed_ =
+      (parameters_count + ArgumentPaddingSlots(parameters_count)) *
+      kSystemPointerSize;
+  frame_size_in_bytes_ = frame_size_in_bytes_without_fixed_ +
+                         ArgumentsAdaptorFrameConstants::kFixedFrameSize;
+}
+
 ConstructStubFrameInfo::ConstructStubFrameInfo(int translation_height,
                                                bool is_topmost,
                                                FrameInfoKind frame_info_kind) {
diff --git a/src/execution/frames.h b/src/execution/frames.h
index 53d6a149e2..3fbb207989 100644
--- a/src/execution/frames.h
+++ b/src/execution/frames.h
@@ -113,6 +113,7 @@ class StackHandler {
     JavaScriptBuiltinContinuationWithCatchFrame)                          \
   V(INTERNAL, InternalFrame)                                              \
   V(CONSTRUCT, ConstructFrame)                                            \
+  V(ARGUMENTS_ADAPTOR, ArgumentsAdaptorFrame)                             \
   V(BUILTIN, BuiltinFrame)                                                \
   V(BUILTIN_EXIT, BuiltinExitFrame)                                       \
   V(NATIVE, NativeFrame)
@@ -215,4 +216,5 @@ class StackFrame {
   }
   bool is_interpreted() const { return type() == INTERPRETED; }
   bool is_baseline() const { return type() == BASELINE; }
+  bool is_arguments_adaptor() const { return type() == ARGUMENTS_ADAPTOR; }
 #if V8_ENABLE_WEBASSEMBLY
@@ -517,6 +519,10 @@ class CommonFrame : public StackFrame {
   // Returns the address of the n'th expression stack element.
   virtual Address GetExpressionAddress(int n) const;
 
+  // Determines if the standard frame for the given frame pointer is
+  // an arguments adaptor frame.
+  static inline bool IsArgumentsAdaptorFrame(Address fp);
+
   // Used by OptimizedFrames and StubFrames.
   void IterateCompiledFrame(RootVisitor* v) const;
 
@@ -544,7 +550,6 @@ class CommonFrameWithJSLinkage : public CommonFrame {
   virtual Object GetParameter(int index) const;
   virtual int ComputeParametersCount() const;
   Handle<FixedArray> GetParameters() const;
-  virtual int GetActualArgumentCount() const;
 
   // Determine the code for the frame.
   Code unchecked_code() const override;
@@ -588,7 +593,6 @@ class JavaScriptFrame : public CommonFrameWithJSLinkage {
   Object unchecked_function() const;
   Script script() const;
   Object context() const override;
-  int GetActualArgumentCount() const override;
 
   inline void set_receiver(Object value);
 
@@ -602,6 +606,11 @@ class JavaScriptFrame : public CommonFrameWithJSLinkage {
   // about the inlined frames use {GetFunctions} and {Summarize}.
   bool HasInlinedFrames() const;
 
+  // Check if this frame has "adapted" arguments in the sense that the
+  // actual passed arguments are available in an arguments adaptor
+  // frame below it on the stack.
+  inline bool has_adapted_arguments() const;
+
   // Garbage collection support.
   void Iterate(RootVisitor* v) const override;
 
@@ -648,6 +657,38 @@ class JavaScriptFrame : public CommonFrameWithJSLinkage {
   friend class StackFrameIteratorBase;
 };
 
+// Arguments adaptor frames are automatically inserted below
+// JavaScript frames when the actual number of parameters does not
+// match the formal number of parameters.
+// NOTE: this inheritance is wrong, an ArgumentsAdaptorFrame should be
+// of type TypedFrame, but due to FrameInspector::javascript_frame(),
+// it needs to be seen as JavaScriptFrame.
+// This frame will however be deleted soon.
+class ArgumentsAdaptorFrame : public JavaScriptFrame {
+ public:
+  Type type() const override { return ARGUMENTS_ADAPTOR; }
+
+  // Determine the code for the frame.
+  Code unchecked_code() const override;
+
+  static ArgumentsAdaptorFrame* cast(StackFrame* frame) {
+    DCHECK(frame->is_arguments_adaptor());
+    return static_cast<ArgumentsAdaptorFrame*>(frame);
+  }
+
+  int ComputeParametersCount() const override;
+
+  // Printing support.
+  void Print(StringStream* accumulator, PrintMode mode,
+             int index) const override;
+
+ protected:
+  inline explicit ArgumentsAdaptorFrame(StackFrameIteratorBase* iterator);
+
+ private:
+  friend class StackFrameIteratorBase;
+};
+
 class NativeFrame : public TypedFrame {
  public:
   Type type() const override { return NATIVE; }
@@ -1382,6 +1423,28 @@ class UnoptimizedFrameInfo {
   uint32_t frame_size_in_bytes_;
 };
 
+class ArgumentsAdaptorFrameInfo {
+ public:
+  static ArgumentsAdaptorFrameInfo Precise(int translation_height) {
+    return ArgumentsAdaptorFrameInfo{translation_height};
+  }
+
+  static ArgumentsAdaptorFrameInfo Conservative(int parameters_count) {
+    return ArgumentsAdaptorFrameInfo{parameters_count};
+  }
+
+  uint32_t frame_size_in_bytes_without_fixed() const {
+    return frame_size_in_bytes_without_fixed_;
+  }
+  uint32_t frame_size_in_bytes() const { return frame_size_in_bytes_; }
+
+ private:
+  explicit ArgumentsAdaptorFrameInfo(int translation_height);
+
+  uint32_t frame_size_in_bytes_without_fixed_;
+  uint32_t frame_size_in_bytes_;
+};
+
 class ConstructStubFrameInfo {
  public:
   static ConstructStubFrameInfo Precise(int translation_height,
diff --git a/src/execution/isolate.cc b/src/execution/isolate.cc
index 8363c52c49..1fd0729df3 100644
--- a/src/execution/isolate.cc
+++ b/src/execution/isolate.cc
@@ -4513,7 +4513,8 @@ void Isolate::PrepareBuiltinLabelInfoMap() {
   if (embedded_file_writer_ != nullptr) {
     embedded_file_writer_->PrepareBuiltinLabelInfoMap(
         heap()->construct_stub_create_deopt_pc_offset().value(),
-        heap()->construct_stub_invoke_deopt_pc_offset().value());
+        heap()->construct_stub_invoke_deopt_pc_offset().value(),
+        heap()->arguments_adaptor_deopt_pc_offset().value());
   }
 }
 
diff --git a/src/heap/heap.cc b/src/heap/heap.cc
index 982b80bb89..da54f275e0 100644
--- a/src/heap/heap.cc
+++ b/src/heap/heap.cc
@@ -159,6 +159,11 @@ void Heap_GenerationalEphemeronKeyBarrierSlow(Heap* heap,
   heap->RecordEphemeronKeyWrite(table, slot);
 }
 
+void Heap::SetArgumentsAdaptorDeoptPCOffset(int pc_offset) {
+  DCHECK_EQ(Smi::zero(), arguments_adaptor_deopt_pc_offset());
+  set_arguments_adaptor_deopt_pc_offset(Smi::FromInt(pc_offset));
+}
+
 void Heap::SetConstructStubCreateDeoptPCOffset(int pc_offset) {
   DCHECK_EQ(Smi::zero(), construct_stub_create_deopt_pc_offset());
   set_construct_stub_create_deopt_pc_offset(Smi::FromInt(pc_offset));
diff --git a/src/heap/heap.h b/src/heap/heap.h
index 61dea819f0..fdc33ac053 100644
--- a/src/heap/heap.h
+++ b/src/heap/heap.h
@@ -1180,6 +1180,7 @@ class Heap {
   // ===========================================================================
 
   // Setters for code offsets of well-known deoptimization targets.
+  void SetArgumentsAdaptorDeoptPCOffset(int pc_offset);
   void SetConstructStubCreateDeoptPCOffset(int pc_offset);
   void SetConstructStubInvokeDeoptPCOffset(int pc_offset);
   void SetInterpreterEntryReturnPCOffset(int pc_offset);
diff --git a/src/roots/roots.h b/src/roots/roots.h
index e7ec614c63..cc8faec75d 100644
--- a/src/roots/roots.h
+++ b/src/roots/roots.h
@@ -316,6 +316,7 @@ class Symbol;
   /* To distinguish the function templates, so that we can find them in the */ \
   /* function cache of the native context. */                                  \
   V(Smi, next_template_serial_number, NextTemplateSerialNumber)                \
+  V(Smi, arguments_adaptor_deopt_pc_offset, ArgumentsAdaptorDeoptPCOffset)     \
   V(Smi, construct_stub_create_deopt_pc_offset,                                \
     ConstructStubCreateDeoptPCOffset)                                          \
   V(Smi, construct_stub_invoke_deopt_pc_offset,                                \
diff --git a/src/runtime/runtime-scopes.cc b/src/runtime/runtime-scopes.cc
index f49689c292..c0ddf4eec6 100644
--- a/src/runtime/runtime-scopes.cc
+++ b/src/runtime/runtime-scopes.cc
@@ -380,7 +380,12 @@ std::unique_ptr<Handle<Object>[]> GetCallerArguments(Isolate* isolate,
 
     return param_data;
   } else {
-    int args_count = frame->GetActualArgumentCount();
+    if (it.frame()->has_adapted_arguments()) {
+      it.AdvanceOneFrame();
+      DCHECK(it.frame()->is_arguments_adaptor());
+    }
+    frame = it.frame();
+    int args_count = frame->ComputeParametersCount();
     *total_argc = args_count;
     std::unique_ptr<Handle<Object>[]> param_data(
         NewArray<Handle<Object>>(*total_argc));
diff --git a/src/snapshot/embedded/embedded-file-writer-interface.h b/src/snapshot/embedded/embedded-file-writer-interface.h
index fd2b50897d..19ec9db01f 100644
--- a/src/snapshot/embedded/embedded-file-writer-interface.h
+++ b/src/snapshot/embedded/embedded-file-writer-interface.h
@@ -40,8 +40,8 @@ class EmbeddedFileWriterInterface {
   // compiled builtin Code objects with trampolines.
   virtual void PrepareBuiltinSourcePositionMap(Builtins* builtins) = 0;
 
-  virtual void PrepareBuiltinLabelInfoMap(int create_offset,
-                                          int invoke_offset) = 0;
+  virtual void PrepareBuiltinLabelInfoMap(int create_offset, int invoke_offset,
+                                          int arguments_adaptor_offset) = 0;
 
 #if defined(V8_OS_WIN64)
   virtual void SetBuiltinUnwindData(
diff --git a/src/snapshot/embedded/embedded-file-writer.cc b/src/snapshot/embedded/embedded-file-writer.cc
index 5adc3e0115..4fd1d51cc9 100644
--- a/src/snapshot/embedded/embedded-file-writer.cc
+++ b/src/snapshot/embedded/embedded-file-writer.cc
@@ -302,12 +302,14 @@ void EmbeddedFileWriter::PrepareBuiltinSourcePositionMap(Builtins* builtins) {
   }
 }
 
-void EmbeddedFileWriter::PrepareBuiltinLabelInfoMap(int create_offset,
-                                                    int invoke_offset) {
+void EmbeddedFileWriter::PrepareBuiltinLabelInfoMap(
+    int create_offset, int invoke_offset, int arguments_adaptor_offset) {
   label_info_[static_cast<int>(Builtin::kJSConstructStubGeneric)].push_back(
       {create_offset, "construct_stub_create_deopt_addr"});
   label_info_[static_cast<int>(Builtin::kJSConstructStubGeneric)].push_back(
       {invoke_offset, "construct_stub_invoke_deopt_addr"});
+  label_info_[static_cast<int>(Builtin::kArgumentsAdaptorTrampoline)].push_back(
+      {arguments_adaptor_offset, "arguments_adaptor_deopt_addr"});
 }
 
 }  // namespace internal
diff --git a/src/snapshot/embedded/embedded-file-writer.h b/src/snapshot/embedded/embedded-file-writer.h
index 4845be036c..af8be5c396 100644
--- a/src/snapshot/embedded/embedded-file-writer.h
+++ b/src/snapshot/embedded/embedded-file-writer.h
@@ -40,8 +40,8 @@ class EmbeddedFileWriter : public EmbeddedFileWriterInterface {
 
   void PrepareBuiltinSourcePositionMap(Builtins* builtins) override;
 
-  void PrepareBuiltinLabelInfoMap(int create_offset,
-                                  int invoke_create) override;
+  void PrepareBuiltinLabelInfoMap(int create_offset, int invoke_create,
+                                  int arguments_adaptor_offset) override;
 
 #if defined(V8_OS_WIN64)
   void SetBuiltinUnwindData(
diff --git a/src/wasm/wasm-code-manager.h b/src/wasm/wasm-code-manager.h
index 2baf46e888..63e9b35665 100644
--- a/src/wasm/wasm-code-manager.h
+++ b/src/wasm/wasm-code-manager.h
@@ -84,6 +84,7 @@ struct WasmModule;
   V(WasmTraceEnter)                       \
   V(WasmTraceExit)                        \
   V(WasmTraceMemory)                      \
+  V(ArgumentsAdaptorTrampoline)           \
   V(BigIntToI32Pair)                      \
   V(BigIntToI64)                          \
   V(DoubleToI)                            \
diff --git a/test/torque/test-torque.tq b/test/torque/test-torque.tq
index 1e11465f5a..07096b752d 100644
--- a/test/torque/test-torque.tq
+++ b/test/torque/test-torque.tq
@@ -711,6 +711,9 @@ macro TestFrame1(implicit context: Context)() {
     case (_f: StandardFrame): {
       unreachable;
     }
+    case (_f: ArgumentsAdaptorFrame): {
+      unreachable;
+    }
     case (_f: StubFrame): {
     }
   }
diff --git a/tools/v8heapconst.py b/tools/v8heapconst.py
index 097b6a7267..cd4545a0e0 100644
--- a/tools/v8heapconst.py
+++ b/tools/v8heapconst.py
@@ -527,6 +527,7 @@ FRAME_MARKERS = (
   "JAVA_SCRIPT_BUILTIN_CONTINUATION_WITH_CATCH",
   "INTERNAL",
   "CONSTRUCT",
+  "ARGUMENTS_ADAPTOR",
   "BUILTIN",
   "BUILTIN_EXIT",
   "NATIVE",
